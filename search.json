[
  {
    "objectID": "toolloop.html",
    "href": "toolloop.html",
    "title": "Tool loop",
    "section": "",
    "text": "import os\n# os.environ['ANTHROPIC_LOG'] = 'debug'\nmodel = models[-1]\nAnthropic provides an interesting example of using tools to mock up a hypothetical ordering system. We’re going to take it a step further, and show how we can dramatically simplify the process, whilst completing more complex tasks.\nWe’ll start by defining the same mock customer/order data as in Anthropic’s example, plus create a entity relationship between customers and orders:\norders = {\n    \"O1\": dict(id=\"O1\", product=\"Widget A\", quantity=2, price=19.99, status=\"Shipped\"),\n    \"O2\": dict(id=\"O2\", product=\"Gadget B\", quantity=1, price=49.99, status=\"Processing\"),\n    \"O3\": dict(id=\"O3\", product=\"Gadget B\", quantity=2, price=49.99, status=\"Shipped\")}\n\ncustomers = {\n    \"C1\": dict(name=\"John Doe\", email=\"john@example.com\", phone=\"123-456-7890\",\n               orders=[orders['O1'], orders['O2']]),\n    \"C2\": dict(name=\"Jane Smith\", email=\"jane@example.com\", phone=\"987-654-3210\",\n               orders=[orders['O3']])\n}\nWe can now define the same functions from the original example – but note that we don’t need to manually create the large JSON schema, since Claudette handles all that for us automatically from the functions directly. We’ll add some extra functionality to update order details when cancelling too.\ndef get_customer_info(\n    customer_id:str # ID of the customer\n): # Customer's name, email, phone number, and list of orders\n    \"Retrieves a customer's information and their orders based on the customer ID\"\n    print(f'- Retrieving customer {customer_id}')\n    return customers.get(customer_id, \"Customer not found\")\n\ndef get_order_details(\n    order_id:str # ID of the order\n): # Order's ID, product name, quantity, price, and order status\n    \"Retrieves the details of a specific order based on the order ID\"\n    print(f'- Retrieving order {order_id}')\n    return orders.get(order_id, \"Order not found\")\n\ndef cancel_order(\n    order_id:str # ID of the order to cancel\n)-&gt;bool: # True if the cancellation is successful\n    \"Cancels an order based on the provided order ID\"\n    print(f'- Cancelling order {order_id}')\n    if order_id not in orders: return False\n    orders[order_id]['status'] = 'Cancelled'\n    return True\nWe’re now ready to start our chat.\ntools = [get_customer_info, get_order_details, cancel_order]\nchat = Chat(model, tools=tools)\nWe’ll start with the same request as Anthropic showed:\nr = chat('Can you tell me the email address for customer C1?')\nprint(r.stop_reason)\nr.content\n\n- Retrieving customer C1\ntool_use\n\n\n[ToolUseBlock(id='toolu_0168sUZoEUpjzk5Y8WN3q9XL', input={'customer_id': 'C1'}, name='get_customer_info', type='tool_use')]\nClaude asks us to use a tool. Claudette handles that automatically by just calling it again:\nr = chat()\ncontents(r)\n\n'The email address for customer C1 is john@example.com.'\nLet’s consider a more complex case than in the original example – what happens if a customer wants to cancel all of their orders?\nchat = Chat(model, tools=tools)\nr = chat('Please cancel all orders for customer C1 for me.')\nprint(r.stop_reason)\nr.content\n\n- Retrieving customer C1\ntool_use\n\n\n[TextBlock(text=\"Okay, let's cancel all orders for customer C1:\", type='text'),\n ToolUseBlock(id='toolu_01ADr1rEp7NLZ2iKWfLp7vz7', input={'customer_id': 'C1'}, name='get_customer_info', type='tool_use')]\nThis is the start of a multi-stage tool use process. Doing it manually step by step is inconvenient, so let’s write a function to handle this for us:\nsource",
    "crumbs": [
      "Tool loop"
    ]
  },
  {
    "objectID": "toolloop.html#code-interpreter",
    "href": "toolloop.html#code-interpreter",
    "title": "Tool loop",
    "section": "Code interpreter",
    "text": "Code interpreter\nHere is an example of using toolloop to implement a simple code interpreter with additional tools.\n\nfrom toolslm.shell import get_shell\nfrom fastcore.meta import delegates\nimport traceback\n\n\n@delegates()\nclass CodeChat(Chat):\n    imps = 'os, warnings, time, json, re, math, collections, itertools, functools, dateutil, datetime, string, types, copy, pprint, enum, numbers, decimal, fractions, random, operator, typing, dataclasses'\n    def __init__(self, model: Optional[str] = None, ask:bool=True, **kwargs):\n        super().__init__(model=model, **kwargs)\n        self.ask = ask\n        self.tools.append(self.run_cell)\n        self.shell = get_shell()\n        self.shell.run_cell('import '+self.imps)\n\nWe have one additional parameter to creating a CodeChat beyond what we pass to Chat, which is ask – if that’s True, we’ll prompt the user before running code.\n\n@patch\ndef run_cell(\n    self:CodeChat,\n    code:str,   # Code to execute in persistent IPython session\n): # Result of expression on last line (if exists); '#DECLINED#' if user declines request to execute\n    \"Asks user for permission, and if provided, executes python `code` using persistent IPython session.\"\n    confirm = f'Press Enter to execute, or enter \"n\" to skip?\\n```\\n{code}\\n```\\n'\n    if self.ask and input(confirm): return '#DECLINED#'\n    try: res = self.shell.run_cell(code)\n    except Exception as e: return traceback.format_exc()\n    return res.stdout if res.result is None else res.result\n\nWe just pass along requests to run code to the shell’s implementation. Claude often prints results instead of just using the last expression, so we capture stdout in those cases.\n\nsp = f'''You are a knowledgable assistant. Do not use tools unless needed.\nDon't do complex calculations yourself -- use code for them.\nThe following modules are pre-imported for `run_cell` automatically:\n\n{CodeChat.imps}\n\nNever mention what tools you are using. Note that `run_cell` interpreter state is *persistent* across calls.\n\nIf a tool returns `#DECLINED#` report to the user that the attempt was declined and no further progress can be made.'''\n\n\ndef get_user(ignored:str='' # Unused parameter\n            ): # Username of current user\n    \"Get the username of the user running this session\"\n    print(\"Looking up username\")\n    return 'Jeremy'\n\nIn order to test out multi-stage tool use, we create a mock function that Claude can call to get the current username.\n\nmodel = models[1]\n\n\nchat = CodeChat(model, tools=[get_user], sp=sp, ask=True, temp=0.3)\n\nClaude gets confused sometimes about how tools work, so we use examples to remind it:\n\nchat.h = [\n    'Calculate the square root of `10332`', 'math.sqrt(10332)',\n    '#DECLINED#', 'I am sorry but the request to execute that was declined and no further progress can be made.'\n]\n\nProviding a callable to toolloop’s trace_func lets us print out information during the loop:\n\ndef _show_cts(h):\n    for r in h:\n        for o in r.get('content'):\n            if hasattr(o,'text'): print(o.text)\n            nm = getattr(o, 'name', None)\n            if nm=='run_cell': print(o.input['code'])\n            elif nm: print(f'{o.name}({o.input})')\n\n…and toolloop’s cont_func callable let’s us provide a function which, if it returns False, stops the loop:\n\ndef _cont_decline(c):\n    return nested_idx(c, 'content', 'content') != '#DECLINED#'\n\nNow we can try our code interpreter. We start by asking for a function to be created, which we’ll use in the next prompt to test that the interpreter is persistent.\n\npr = '''Create a 1-line function `checksum` for a string `s`,\nthat multiplies together the ascii values of each character in `s` using `reduce`.'''\nchat.toolloop(pr, temp=0.2, trace_func=_show_cts, cont_func=_cont_decline)\n\nPress Enter to execute, or enter \"n\" to skip?\n```\nchecksum = lambda s: functools.reduce(lambda x, y: x * ord(y), s, 1)\n```\n\nCreate a 1-line function `checksum` for a string `s`,\nthat multiplies together the ascii values of each character in `s` using `reduce`.\nLet me help you create that function using `reduce` and `functools`.\nchecksum = lambda s: functools.reduce(lambda x, y: x * ord(y), s, 1)\nThe function has been created. Let me explain how it works:\n1. It takes a string `s` as input\n2. Uses `functools.reduce` to multiply together all ASCII values\n3. `ord(y)` gets the ASCII value of each character\n4. The initial value is 1 (the third parameter to reduce)\n5. The lambda function multiplies the accumulator (x) with each new ASCII value\n\nYou can test it with any string. For example, you could try `checksum(\"hello\")` to see it in action.\n\n\nThe function has been created. Let me explain how it works: 1. It takes a string s as input 2. Uses functools.reduce to multiply together all ASCII values 3. ord(y) gets the ASCII value of each character 4. The initial value is 1 (the third parameter to reduce) 5. The lambda function multiplies the accumulator (x) with each new ASCII value\nYou can test it with any string. For example, you could try checksum(\"hello\") to see it in action.\n\n\nid: msg_011pcGY9LbYqvRSfDPgCqUkT\ncontent: [{'text': 'The function has been created. Let me explain how it works:\\n1. It takes a stringsas input\\n2. Usesfunctools.reduceto multiply together all ASCII values\\n3.ord(y)gets the ASCII value of each character\\n4. The initial value is 1 (the third parameter to reduce)\\n5. The lambda function multiplies the accumulator (x) with each new ASCII value\\n\\nYou can test it with any string. For example, you could trychecksum(“hello”)to see it in action.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 824, 'output_tokens': 125, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nBy asking for a calculation to be done on the username, we force it to use multiple steps:\n\npr = 'Use it to get the checksum of the username of this session.'\nchat.toolloop(pr, trace_func=_show_cts)\n\nLooking up username\nUse it to get the checksum of the username of this session.\nI'll first get the username using `get_user` and then apply our `checksum` function to it.\nget_user({'ignored': ''})\nPress Enter to execute, or enter \"n\" to skip?\n```\nprint(checksum(\"Jeremy\"))\n```\n\nNow I'll calculate the checksum of \"Jeremy\":\nprint(checksum(\"Jeremy\"))\nThe checksum of the username \"Jeremy\" is 1134987783204. This was calculated by multiplying together the ASCII values of each character in \"Jeremy\".\n\n\nThe checksum of the username “Jeremy” is 1134987783204. This was calculated by multiplying together the ASCII values of each character in “Jeremy”.\n\n\nid: msg_01UXvtcLzzykZpnQUT35v4uD\ncontent: [{'text': 'The checksum of the username \"Jeremy\" is 1134987783204. This was calculated by multiplying together the ASCII values of each character in \"Jeremy\".', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 1143, 'output_tokens': 38, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}",
    "crumbs": [
      "Tool loop"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Claudette’s source",
    "section": "",
    "text": "This is the ‘literate’ source code for Claudette. You can view the fully rendered version of the notebook here, or you can clone the git repo and run the interactive notebook in Jupyter. The notebook is converted the Python module claudette/core.py using nbdev. The goal of this source code is to both create the Python module, and also to teach the reader how it is created, without assuming much existing knowledge about Claude’s API.\nMost of the time you’ll see that we write some source code first, and then a description or discussion of it afterwards.",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#setup",
    "href": "core.html#setup",
    "title": "Claudette’s source",
    "section": "Setup",
    "text": "Setup\n\nimport os\n# os.environ['ANTHROPIC_LOG'] = 'debug'\n\nTo print every HTTP request and response in full, uncomment the above line. This functionality is provided by Anthropic’s SDK.\n\n\n\n\n\n\nTip\n\n\n\nIf you’re reading the rendered version of this notebook, you’ll see an “Exported source” collapsible widget below. If you’re reading the source notebook directly, you’ll see #| exports at the top of the cell. These show that this piece of code will be exported into the python module that this notebook creates. No other code will be included – any other code in this notebook is just for demonstration, documentation, and testing.\nYou can toggle expanding/collapsing the source code of all exported sections by using the &lt;/&gt; Code menu in the top right of the rendered notebook page.\n\n\n\n\nExported source\nmodel_types = {\n    # Anthropic\n    'claude-3-opus-20240229': 'opus',\n    'claude-3-5-sonnet-20241022': 'sonnet',\n    'claude-3-haiku-20240307': 'haiku-3',\n    'claude-3-5-haiku-20241022': 'haiku-3-5',\n    # AWS\n    'anthropic.claude-3-opus-20240229-v1:0': 'opus',\n    'anthropic.claude-3-5-sonnet-20241022-v2:0': 'sonnet',\n    'anthropic.claude-3-sonnet-20240229-v1:0': 'sonnet',\n    'anthropic.claude-3-haiku-20240307-v1:0': 'haiku',\n    # Google\n    'claude-3-opus@20240229': 'opus',\n    'claude-3-5-sonnet-v2@20241022': 'sonnet',\n    'claude-3-sonnet@20240229': 'sonnet',\n    'claude-3-haiku@20240307': 'haiku',\n}\n\nall_models = list(model_types)\n\n\n\n\nExported source\ntext_only_models = ('claude-3-5-haiku-20241022',)\n\n\nThese are the current versions and prices of Anthropic’s models at the time of writing.\n\nmodel = models[1]; model\n\n'claude-3-5-sonnet-20241022'\n\n\nFor examples, we’ll use Sonnet 3.5, since it’s awesome.",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#antropic-sdk",
    "href": "core.html#antropic-sdk",
    "title": "Claudette’s source",
    "section": "Antropic SDK",
    "text": "Antropic SDK\n\ncli = Anthropic()\n\nThis is what Anthropic’s SDK provides for interacting with Python. To use it, pass it a list of messages, with content and a role. The roles should alternate between user and assistant.\n\n\n\n\n\n\nTip\n\n\n\nAfter the code below you’ll see an indented section with an orange vertical line on the left. This is used to show the result of running the code above. Because the code is running in a Jupyter Notebook, we don’t have to use print to display results, we can just type the expression directly, as we do with r here.\n\n\n\nm = {'role': 'user', 'content': \"I'm Jeremy\"}\nr = cli.messages.create(messages=[m], model=model, max_tokens=100)\nr\n\nHi Jeremy! Nice to meet you. I’m Claude, an AI assistant. How can I help you today?\n\n\nid: msg_017Q8WYvvANfyHWLJWt95UR1\ncontent: [{'text': \"Hi Jeremy! Nice to meet you. I'm Claude, an AI assistant. How can I help you today?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 27}\n\n\n\n\n\nFormatting output\nThat output is pretty long and hard to read, so let’s clean it up. We’ll start by pulling out the Content part of the message. To do that, we’re going to write our first function which will be included to the claudette/core.py module.\n\n\n\n\n\n\nTip\n\n\n\nThis is the first exported public function or class we’re creating (the previous export was of a variable). In the rendered version of the notebook for these you’ll see 4 things, in this order (unless the symbol starts with a single _, which indicates it’s private):\n\nThe signature (with the symbol name as a heading, with a horizontal rule above)\nA table of paramater docs (if provided)\nThe doc string (in italics).\nThe source code (in a collapsible “Exported source” block)\n\nAfter that, we generally provide a bit more detail on what we’ve created, and why, along with a sample usage.\n\n\n\nsource\n\n\nfind_block\n\n find_block (r:collections.abc.Mapping, blk_type:type=&lt;class\n             'anthropic.types.text_block.TextBlock'&gt;)\n\nFind the first block of type blk_type in r.content.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nr\nMapping\n\nThe message to look in\n\n\nblk_type\ntype\nTextBlock\nThe type of block to find\n\n\n\n\n\nExported source\ndef find_block(r:abc.Mapping, # The message to look in\n               blk_type:type=TextBlock  # The type of block to find\n              ):\n    \"Find the first block of type `blk_type` in `r.content`.\"\n    return first(o for o in r.content if isinstance(o,blk_type))\n\n\nThis makes it easier to grab the needed parts of Claude’s responses, which can include multiple pieces of content. By default, we look for the first text block. That will generally have the content we want to display.\n\nfind_block(r)\n\nTextBlock(text=\"Hi Jeremy! Nice to meet you. I'm Claude, an AI assistant. How can I help you today?\", type='text')\n\n\n\nsource\n\n\ncontents\n\n contents (r)\n\nHelper to get the contents from Claude response r.\n\n\nExported source\ndef contents(r):\n    \"Helper to get the contents from Claude response `r`.\"\n    blk = find_block(r)\n    if not blk and r.content: blk = r.content[0]\n    return blk.text.strip() if hasattr(blk,'text') else str(blk)\n\n\nFor display purposes, we often just want to show the text itself.\n\ncontents(r)\n\n\"Hi Jeremy! Nice to meet you. I'm Claude, an AI assistant. How can I help you today?\"\n\n\n\n\nExported source\n@patch\ndef _repr_markdown_(self:(Message)):\n    det = '\\n- '.join(f'{k}: `{v}`' for k,v in self.model_dump().items())\n    cts = re.sub(r'\\$', '&#36;', contents(self))  # escape `$` for jupyter latex\n    return f\"\"\"{cts}\n\n&lt;details&gt;\n\n- {det}\n\n&lt;/details&gt;\"\"\"\n\n\nJupyter looks for a _repr_markdown_ method in displayed objects; we add this in order to display just the content text, and collapse full details into a hideable section. Note that patch is from fastcore, and is used to add (or replace) functionality in an existing class. We pass the class(es) that we want to patch as type annotations to self. In this case, _repr_markdown_ is being added to Anthropic’s Message class, so when we display the message now we just see the contents, and the details are hidden away in a collapsible details block.\n\nr\n\nHi Jeremy! Nice to meet you. I’m Claude, an AI assistant. How can I help you today?\n\n\nid: msg_017Q8WYvvANfyHWLJWt95UR1\ncontent: [{'text': \"Hi Jeremy! Nice to meet you. I'm Claude, an AI assistant. How can I help you today?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 27}\n\n\n\n\nOne key part of the response is the usage key, which tells us how many tokens we used by returning a Usage object.\nWe’ll add some helpers to make things a bit cleaner for creating and formatting these objects.\n\nr.usage\n\nIn: 10; Out: 27; Cache create: 0; Cache read: 0; Total: 37\n\n\n\nsource\n\n\nusage\n\n usage (inp=0, out=0, cache_create=0, cache_read=0)\n\nSlightly more concise version of Usage.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ninp\nint\n0\ninput tokens\n\n\nout\nint\n0\nOutput tokens\n\n\ncache_create\nint\n0\nCache creation tokens\n\n\ncache_read\nint\n0\nCache read tokens\n\n\n\n\n\nExported source\ndef usage(inp=0, # input tokens\n          out=0,  # Output tokens\n          cache_create=0, # Cache creation tokens\n          cache_read=0 # Cache read tokens\n         ):\n    \"Slightly more concise version of `Usage`.\"\n    return Usage(input_tokens=inp, output_tokens=out, cache_creation_input_tokens=cache_create, cache_read_input_tokens=cache_read)\n\n\nThe constructor provided by Anthropic is rather verbose, so we clean it up a bit, using a lowercase version of the name.\n\nusage(5)\n\nIn: 5; Out: 0; Cache create: 0; Cache read: 0; Total: 5\n\n\n\nsource\n\n\nUsage.total\n\n Usage.total ()\n\n\n\nExported source\n@patch(as_prop=True)\ndef total(self:Usage): return self.input_tokens+self.output_tokens+getattr(self, \"cache_creation_input_tokens\",0)+getattr(self, \"cache_read_input_tokens\",0)\n\n\nAdding a total property to Usage makes it easier to see how many tokens we’ve used up altogether.\n\nusage(5,1).total\n\n6\n\n\n\nsource\n\n\nUsage.__repr__\n\n Usage.__repr__ ()\n\nReturn repr(self).\n\n\nExported source\n@patch\ndef __repr__(self:Usage): return f'In: {self.input_tokens}; Out: {self.output_tokens}; Cache create: {getattr(self, \"cache_creation_input_tokens\",0)}; Cache read: {getattr(self, \"cache_read_input_tokens\",0)}; Total: {self.total}'\n\n\nIn python, patching __repr__ lets us change how an object is displayed. (More generally, methods starting and ending in __ in Python are called dunder methods, and have some magic behavior – such as, in this case, changing how an object is displayed.)\n\nusage(5)\n\nIn: 5; Out: 0; Cache create: 0; Cache read: 0; Total: 5\n\n\n\nsource\n\n\nUsage.__add__\n\n Usage.__add__ (b)\n\nAdd together each of input_tokens and output_tokens\n\n\nExported source\n@patch\ndef __add__(self:Usage, b):\n    \"Add together each of `input_tokens` and `output_tokens`\"\n    return usage(self.input_tokens+b.input_tokens, self.output_tokens+b.output_tokens, getattr(self,'cache_creation_input_tokens',0)+getattr(b,'cache_creation_input_tokens',0), getattr(self,'cache_read_input_tokens',0)+getattr(b,'cache_read_input_tokens',0))\n\n\nAnd, patching __add__ lets + work on a Usage object.\n\nr.usage+r.usage\n\nIn: 20; Out: 54; Cache create: 0; Cache read: 0; Total: 74\n\n\n\n\nCreating messages\nCreating correctly formatted dicts from scratch every time isn’t very handy, so next up we’ll add helpers for this.\n\ndef mk_msg(content, role='user', **kw):\n    return dict(role=role, content=content, **kw)\n\nWe make things a bit more convenient by writing a function to create a message for us.\n\n\n\n\n\n\nNote\n\n\n\nYou may have noticed that we didn’t export the mk_msg function (i.e. there’s no “Exported source” block around it). That’s because we’ll need more functionality in our final version than this version has – so we’ll be defining a more complete version later. Rather than refactoring/editing in notebooks, often it’s helpful to simply gradually build up complexity by re-defining a symbol.\n\n\n\nprompt = \"I'm Jeremy\"\nm = mk_msg(prompt)\nm\n\n{'role': 'user', 'content': \"I'm Jeremy\"}\n\n\n\nr = cli.messages.create(messages=[m], model=model, max_tokens=100)\nr\n\nHi Jeremy! I’m Claude. Nice to meet you. How can I help you today?\n\n\nid: msg_01BhkuvQtEPoC8wHSbU7YRpV\ncontent: [{'text': \"Hi Jeremy! I'm Claude. Nice to meet you. How can I help you today?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 24}\n\n\n\n\n\nsource\n\n\nmk_msgs\n\n mk_msgs (msgs:list, **kw)\n\nHelper to set ‘assistant’ role on alternate messages.\n\n\nExported source\ndef mk_msgs(msgs:list, **kw):\n    \"Helper to set 'assistant' role on alternate messages.\"\n    if isinstance(msgs,str): msgs=[msgs]\n    return [mk_msg(o, ('user','assistant')[i%2], **kw) for i,o in enumerate(msgs)]\n\n\nLLMs, including Claude, don’t actually have state, but instead dialogs are created by passing back all previous prompts and responses every time. With Claude, they always alternate user and assistant. Therefore we create a function to make it easier to build up these dialog lists.\nBut to do so, we need to update mk_msg so that we can’t only pass a str as content, but can also pass a dict or an object with a content attr, since these are both types of message that Claude can create. To do so, we check for a content key or attr, and use it if found.\n\n\nExported source\ndef _str_if_needed(o):\n    if isinstance(o, (list,tuple,abc.Mapping,L)) or hasattr(o, '__pydantic_serializer__'): return o\n    return str(o)\n\n\n\ndef mk_msg(content, role='user', **kw):\n    \"Helper to create a `dict` appropriate for a Claude message. `kw` are added as key/value pairs to the message\"\n    if hasattr(content, 'content'): content,role = content.content,content.role\n    if isinstance(content, abc.Mapping): content=content['content']\n    return dict(role=role, content=_str_if_needed(content), **kw)\n\n\nmsgs = mk_msgs([prompt, r, 'I forgot my name. Can you remind me please?'])\nmsgs\n\n[{'role': 'user', 'content': \"I'm Jeremy\"},\n {'role': 'assistant',\n  'content': [TextBlock(text=\"Hi Jeremy! I'm Claude. Nice to meet you. How can I help you today?\", type='text')]},\n {'role': 'user', 'content': 'I forgot my name. Can you remind me please?'}]\n\n\nNow, if we pass this list of messages to Claude, the model treats it as a conversation to respond to.\n\ncli.messages.create(messages=msgs, model=model, max_tokens=200)\n\nYou just told me your name is Jeremy.\n\n\nid: msg_01KZski1R3z1iGjF6XsBb9dM\ncontent: [{'text': 'You just told me your name is Jeremy.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 46, 'output_tokens': 13}",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#client",
    "href": "core.html#client",
    "title": "Claudette’s source",
    "section": "Client",
    "text": "Client\n\nsource\n\nClient\n\n Client (model, cli=None, log=False)\n\nBasic Anthropic messages client.\n\n\nExported source\nclass Client:\n    def __init__(self, model, cli=None, log=False):\n        \"Basic Anthropic messages client.\"\n        self.model,self.use = model,usage()\n        self.text_only = model in text_only_models\n        self.log = [] if log else None\n        self.c = (cli or Anthropic(default_headers={'anthropic-beta': 'prompt-caching-2024-07-31'}))\n\n\nWe’ll create a simple Client for Anthropic which tracks usage stores the model to use. We don’t add any methods right away – instead we’ll use patch for that so we can add and document them incrementally.\n\nc = Client(model)\nc.use\n\nIn: 0; Out: 0; Cache create: 0; Cache read: 0; Total: 0\n\n\n\n\nExported source\n@patch\ndef _r(self:Client, r:Message, prefill=''):\n    \"Store the result of the message and accrue total usage.\"\n    if prefill:\n        blk = find_block(r)\n        blk.text = prefill + (blk.text or '')\n    self.result = r\n    self.use += r.usage\n    self.stop_reason = r.stop_reason\n    self.stop_sequence = r.stop_sequence\n    return r\n\n\nWe use a _ prefix on private methods, but we document them here in the interests of literate source code.\n_r will be used each time we get a new result, to track usage and also to keep the result available for later.\n\nc._r(r)\nc.use\n\nIn: 10; Out: 24; Cache create: 0; Cache read: 0; Total: 34\n\n\nWhereas OpenAI’s models use a stream parameter for streaming, Anthropic’s use a separate method. We implement Anthropic’s approach in a private method, and then use a stream parameter in __call__ for consistency:\n\n\nExported source\n@patch\ndef _log(self:Client, final, prefill, msgs, maxtok=None, sp=None, temp=None, stream=None, stop=None, **kwargs):\n    self._r(final, prefill)\n    if self.log is not None: self.log.append({\n        \"msgs\": msgs, \"prefill\": prefill, **kwargs,\n        \"msgs\": msgs, \"prefill\": prefill, \"maxtok\": maxtok, \"sp\": sp, \"temp\": temp, \"stream\": stream, \"stop\": stop, **kwargs,\n        \"result\": self.result, \"use\": self.use, \"stop_reason\": self.stop_reason, \"stop_sequence\": self.stop_sequence\n    })\n    return self.result\n\n\n\n\nExported source\n@patch\ndef _stream(self:Client, msgs:list, prefill='', **kwargs):\n    with self.c.messages.stream(model=self.model, messages=mk_msgs(msgs), **kwargs) as s:\n        if prefill: yield(prefill)\n        yield from s.text_stream\n        self._log(s.get_final_message(), prefill, msgs, **kwargs)\n\n\nClaude supports adding an extra assistant message at the end, which contains the prefill – i.e. the text we want Claude to assume the response starts with. However Claude doesn’t actually repeat that in the response, so for convenience we add it.\n\n\nExported source\n@patch\ndef _precall(self:Client, msgs, prefill, stop, kwargs):\n    pref = [prefill.strip()] if prefill else []\n    if not isinstance(msgs,list): msgs = [msgs]\n    if stop is not None:\n        if not isinstance(stop, (list)): stop = [stop]\n        kwargs[\"stop_sequences\"] = stop\n    msgs = mk_msgs(msgs+pref)\n    return msgs\n\n\n\n@patch\n@delegates(messages.Messages.create)\ndef __call__(self:Client,\n             msgs:list, # List of messages in the dialog\n             sp='', # The system prompt\n             temp=0, # Temperature\n             maxtok=4096, # Maximum tokens\n             prefill='', # Optional prefill to pass to Claude as start of its response\n             stream:bool=False, # Stream response?\n             stop=None, # Stop sequence\n             **kwargs):\n    \"Make a call to Claude.\"\n    msgs = self._precall(msgs, prefill, stop, kwargs)\n    if stream: return self._stream(msgs, prefill=prefill, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    res = self.c.messages.create(\n        model=self.model, messages=msgs, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    return self._log(res, prefill, msgs, maxtok, sp, temp, stream=stream, **kwargs)\n\nDefining __call__ let’s us use an object like a function (i.e it’s callable). We use it as a small wrapper over messages.create. However we’re not exporting this version just yet – we have some additions we’ll make in a moment…\n\nc = Client(model, log=True)\nc.use\n\nIn: 0; Out: 0; Cache create: 0; Cache read: 0; Total: 0\n\n\n\nc('Hi')\n\nHello! How can I help you today?\n\n\nid: msg_01DZfHpTqbodjegmvG6kkQvn\ncontent: [{'text': 'Hello! How can I help you today?', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 8, 'output_tokens': 22, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nc.use\n\nIn: 8; Out: 22; Cache create: 0; Cache read: 0; Total: 30\n\n\nLet’s try out prefill:\n\nq = \"Concisely, what is the meaning of life?\"\npref = 'According to Douglas Adams,'\n\n\nc(q, prefill=pref)\n\nAccording to Douglas Adams, it’s 42. More seriously, there’s no universal answer - it’s deeply personal. Common perspectives include: finding happiness, making meaningful connections, pursuing purpose through work/creativity, helping others, or simply experiencing and appreciating existence.\n\n\nid: msg_01RKAjFBMhyBjvKw59ypM6tp\ncontent: [{'text': \"According to Douglas Adams,  it's 42. More seriously, there's no universal answer - it's deeply personal. Common perspectives include: finding happiness, making meaningful connections, pursuing purpose through work/creativity, helping others, or simply experiencing and appreciating existence.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 24, 'output_tokens': 53, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nWe can pass stream=True to stream the response back incrementally:\n\nfor o in c('Hi', stream=True): print(o, end='')\n\nHello! How can I help you today?\n\n\n\nc.use\n\nIn: 40; Out: 97; Cache create: 0; Cache read: 0; Total: 137\n\n\n\nfor o in c(q, prefill=pref, stream=True): print(o, end='')\n\nAccording to Douglas Adams,  it's 42. More seriously, there's no universal answer - it's deeply personal. Common perspectives include: finding happiness, making meaningful connections, pursuing purpose through work/creativity, helping others, or simply experiencing and appreciating existence.\n\n\n\nc.use\n\nIn: 64; Out: 150; Cache create: 0; Cache read: 0; Total: 214\n\n\nPass a stop seauence if you want claude to stop generating text when it encounters it.\n\nc(\"Count from 1 to 10\", stop=\"5\")\n\n1 2 3 4\n\n\nid: msg_01D3kdCAHNbXadE144FLPbQV\ncontent: [{'text': '1\\n2\\n3\\n4\\n', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: stop_sequence\nstop_sequence: 5\ntype: message\nusage: {'input_tokens': 15, 'output_tokens': 11, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nThis also works with streaming, and you can pass more than one stop sequence:\n\nfor o in c(\"Count from 1 to 10\", stop=[\"2\", \"yellow\"], stream=True): print(o, end='')\nprint(c.stop_reason, c.stop_sequence)\n\n1\nstop_sequence 2\n\n\nYou can check the logs:\n\nc.log[-1]\n\n{'msgs': [{'role': 'user', 'content': 'Count from 1 to 10'}],\n 'prefill': '',\n 'max_tokens': 4096,\n 'system': '',\n 'temperature': 0,\n 'stop_sequences': ['2', 'yellow'],\n 'maxtok': None,\n 'sp': None,\n 'temp': None,\n 'stream': None,\n 'stop': None,\n 'result': Message(id='msg_01PbJN7QLwYALfoqTtYJHYVR', content=[TextBlock(text='1\\n', type='text')], model='claude-3-5-sonnet-20241022', role='assistant', stop_reason='stop_sequence', stop_sequence='2', type='message', usage=In: 15; Out: 11; Cache create: 0; Cache read: 0; Total: 26),\n 'use': In: 94; Out: 172; Cache create: 0; Cache read: 0; Total: 266,\n 'stop_reason': 'stop_sequence',\n 'stop_sequence': '2'}",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#tool-use",
    "href": "core.html#tool-use",
    "title": "Claudette’s source",
    "section": "Tool use",
    "text": "Tool use\nLet’s now add tool use (aka function calling).\n\nsource\n\nmk_tool_choice\n\n mk_tool_choice (choose:Union[str,bool,NoneType])\n\nCreate a tool_choice dict that’s ‘auto’ if choose is None, ‘any’ if it is True, or ‘tool’ otherwise\n\n\nExported source\ndef mk_tool_choice(choose:Union[str,bool,None])-&gt;dict:\n    \"Create a `tool_choice` dict that's 'auto' if `choose` is `None`, 'any' if it is True, or 'tool' otherwise\"\n    return {\"type\": \"tool\", \"name\": choose} if isinstance(choose,str) else {'type':'any'} if choose else {'type':'auto'}\n\n\n\nprint(mk_tool_choice('sums'))\nprint(mk_tool_choice(True))\nprint(mk_tool_choice(None))\n\n{'type': 'tool', 'name': 'sums'}\n{'type': 'any'}\n{'type': 'auto'}\n\n\nClaude can be forced to use a particular tool, or select from a specific list of tools, or decide for itself when to use a tool. If you want to force a tool (or force choosing from a list), include a tool_choice param with a dict from mk_tool_choice.\nFor testing, we need a function that Claude can call; we’ll write a simple function that adds numbers together, and will tell us when it’s being called:\n\ndef sums(\n    a:int,  # First thing to sum\n    b:int=1 # Second thing to sum\n) -&gt; int: # The sum of the inputs\n    \"Adds a + b.\"\n    print(f\"Finding the sum of {a} and {b}\")\n    return a + b\n\n\na,b = 604542,6458932\npr = f\"What is {a}+{b}?\"\nsp = \"You are a summing expert.\"\n\nClaudette can autogenerate a schema thanks to the toolslm library. We’ll force the use of the tool using the function we created earlier.\n\ntools=[get_schema(sums)]\nchoice = mk_tool_choice('sums')\n\nWe’ll start a dialog with Claude now. We’ll store the messages of our dialog in msgs. The first message will be our prompt pr, and we’ll pass our tools schema.\n\nmsgs = mk_msgs(pr)\nr = c(msgs, sp=sp, tools=tools, tool_choice=choice)\nr\n\nToolUseBlock(id=‘toolu_01JEJNPyeeGm7uwckeF5J4pf’, input={‘a’: 604542, ‘b’: 6458932}, name=‘sums’, type=‘tool_use’)\n\n\nid: msg_015eEr2H8V4j8nNEh1KQifjH\ncontent: [{'id': 'toolu_01JEJNPyeeGm7uwckeF5J4pf', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 442, 'output_tokens': 55, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nWhen Claude decides that it should use a tool, it passes back a ToolUseBlock with the name of the tool to call, and the params to use.\nWe don’t want to allow it to call just any possible function (that would be a security disaster!) so we create a namespace – that is, a dictionary of allowable function names to call.\n\nns = mk_ns(sums)\nns\n\n{'sums': &lt;function __main__.sums(a: int, b: int = 1) -&gt; int&gt;}\n\n\n\nsource\n\n\nmk_funcres\n\n mk_funcres (tuid, res)\n\nGiven tool use id and the tool result, create a tool_result response.\n\n\nExported source\ndef mk_funcres(tuid, res):\n    \"Given tool use id and the tool result, create a tool_result response.\"\n    return dict(type=\"tool_result\", tool_use_id=tuid, content=str(res))\n\n\nWe can now use the function requested by Claude. We look it up in ns, and pass in the provided parameters.\n\nfc = find_block(r, ToolUseBlock)\nres = mk_funcres(fc.id, call_func(fc.name, fc.input, ns=ns))\nres\n\nFinding the sum of 604542 and 6458932\n\n\n{'type': 'tool_result',\n 'tool_use_id': 'toolu_01JEJNPyeeGm7uwckeF5J4pf',\n 'content': '7063474'}\n\n\n\nsource\n\n\nmk_toolres\n\n mk_toolres (r:collections.abc.Mapping,\n             ns:Optional[collections.abc.Mapping]=None, obj:Optional=None)\n\nCreate a tool_result message from response r.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nr\nMapping\n\nTool use request response from Claude\n\n\nns\nOptional\nNone\nNamespace to search for tools\n\n\nobj\nOptional\nNone\nClass to search for tools\n\n\n\n\n\nExported source\ndef mk_toolres(\n    r:abc.Mapping, # Tool use request response from Claude\n    ns:Optional[abc.Mapping]=None, # Namespace to search for tools\n    obj:Optional=None # Class to search for tools\n    ):\n    \"Create a `tool_result` message from response `r`.\"\n    cts = getattr(r, 'content', [])\n    res = [mk_msg(r)]\n    if ns is None: ns=globals()\n    if obj is not None: ns = mk_ns(obj)\n    tcs = [mk_funcres(o.id, call_func(o.name, o.input, ns)) for o in cts if isinstance(o,ToolUseBlock)]\n    if tcs: res.append(mk_msg(tcs))\n    return res\n\n\nIn order to tell Claude the result of the tool call, we pass back the tool use assistant request and the tool_result response.\n\ntr = mk_toolres(r, ns=ns)\ntr\n\nFinding the sum of 604542 and 6458932\n\n\n[{'role': 'assistant',\n  'content': [ToolUseBlock(id='toolu_01JEJNPyeeGm7uwckeF5J4pf', input={'a': 604542, 'b': 6458932}, name='sums', type='tool_use')]},\n {'role': 'user',\n  'content': [{'type': 'tool_result',\n    'tool_use_id': 'toolu_01JEJNPyeeGm7uwckeF5J4pf',\n    'content': '7063474'}]}]\n\n\nWe add this to our dialog, and now Claude has all the information it needs to answer our question.\n\nmsgs += tr\ncontents(c(msgs, sp=sp, tools=tools))\n\n'The sum of 604542 and 6458932 is 7063474.'\n\n\n\nmsgs\n\n[{'role': 'user', 'content': 'What is 604542+6458932?'},\n {'role': 'assistant',\n  'content': [ToolUseBlock(id='toolu_01JEJNPyeeGm7uwckeF5J4pf', input={'a': 604542, 'b': 6458932}, name='sums', type='tool_use')]},\n {'role': 'user',\n  'content': [{'type': 'tool_result',\n    'tool_use_id': 'toolu_01JEJNPyeeGm7uwckeF5J4pf',\n    'content': '7063474'}]}]\n\n\nThis works with methods as well – in this case, use the object itself for ns:\n\nclass Dummy:\n    def sums(\n        self,\n        a:int,  # First thing to sum\n        b:int=1 # Second thing to sum\n    ) -&gt; int: # The sum of the inputs\n        \"Adds a + b.\"\n        print(f\"Finding the sum of {a} and {b}\")\n        return a + b\n\n\ntools = [get_schema(Dummy.sums)]\no = Dummy()\nr = c(pr, sp=sp, tools=tools, tool_choice=choice)\ntr = mk_toolres(r, obj=o)\nmsgs += tr\ncontents(c(msgs, sp=sp, tools=tools))\n\nFinding the sum of 604542 and 6458932\n\n\n'The sum of 604542 and 6458932 is 7063474.'\n\n\n\nsource\n\n\nget_types\n\n get_types (msgs)\n\n\nget_types(msgs)\n\n['text', 'tool_use', 'tool_result', 'tool_use', 'tool_result']\n\n\n\nsource\n\n\nClient.__call__\n\n Client.__call__ (msgs:list, sp='', temp=0, maxtok=4096, prefill='',\n                  stream:bool=False, stop=None, tools:Optional[list]=None,\n                  tool_choice:Optional[dict]=None,\n                  metadata:MetadataParam|NotGiven=NOT_GIVEN,\n                  stop_sequences:List[str]|NotGiven=NOT_GIVEN, system:Unio\n                  n[str,Iterable[TextBlockParam]]|NotGiven=NOT_GIVEN,\n                  temperature:float|NotGiven=NOT_GIVEN,\n                  top_k:int|NotGiven=NOT_GIVEN,\n                  top_p:float|NotGiven=NOT_GIVEN,\n                  extra_headers:Headers|None=None,\n                  extra_query:Query|None=None, extra_body:Body|None=None,\n                  timeout:float|httpx.Timeout|None|NotGiven=NOT_GIVEN)\n\nMake a call to Claude.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmsgs\nlist\n\nList of messages in the dialog\n\n\nsp\nstr\n\nThe system prompt\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nstream\nbool\nFalse\nStream response?\n\n\nstop\nNoneType\nNone\nStop sequence\n\n\ntools\nOptional\nNone\nList of tools to make available to Claude\n\n\ntool_choice\nOptional\nNone\nOptionally force use of some tool\n\n\nmetadata\nMetadataParam | NotGiven\nNOT_GIVEN\n\n\n\nstop_sequences\nList[str] | NotGiven\nNOT_GIVEN\n\n\n\nsystem\nUnion[str, Iterable[TextBlockParam]] | NotGiven\nNOT_GIVEN\n\n\n\ntemperature\nfloat | NotGiven\nNOT_GIVEN\n\n\n\ntop_k\nint | NotGiven\nNOT_GIVEN\n\n\n\ntop_p\nfloat | NotGiven\nNOT_GIVEN\n\n\n\nextra_headers\nHeaders | None\nNone\n\n\n\nextra_query\nQuery | None\nNone\n\n\n\nextra_body\nBody | None\nNone\n\n\n\ntimeout\nfloat | httpx.Timeout | None | NotGiven\nNOT_GIVEN\n\n\n\n\n\n\nExported source\n@patch\n@delegates(messages.Messages.create)\ndef __call__(self:Client,\n             msgs:list, # List of messages in the dialog\n             sp='', # The system prompt\n             temp=0, # Temperature\n             maxtok=4096, # Maximum tokens\n             prefill='', # Optional prefill to pass to Claude as start of its response\n             stream:bool=False, # Stream response?\n             stop=None, # Stop sequence\n             tools:Optional[list]=None, # List of tools to make available to Claude\n             tool_choice:Optional[dict]=None, # Optionally force use of some tool\n             **kwargs):\n    \"Make a call to Claude.\"\n    if tools: kwargs['tools'] = [get_schema(o) for o in listify(tools)]\n    if tool_choice: kwargs['tool_choice'] = mk_tool_choice(tool_choice)\n    msgs = self._precall(msgs, prefill, stop, kwargs)\n    if any(t == 'image' for t in get_types(msgs)): assert not self.text_only, f\"Images are not supported by the current model type: {self.model}\"\n    if stream: return self._stream(msgs, prefill=prefill, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    res = self.c.messages.create(model=self.model, messages=msgs, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    return self._log(res, prefill, msgs, maxtok, sp, temp, stream=stream, stop=stop, **kwargs)\n\n\n\nr = c(pr, sp=sp, tools=sums, tool_choice=sums)\nr\n\nToolUseBlock(id=‘toolu_01KNbjuc8utt6ZroFngmAcuj’, input={‘a’: 604542, ‘b’: 6458932}, name=‘sums’, type=‘tool_use’)\n\n\nid: msg_01T8zmguPksQaKLLgUuaYAJL\ncontent: [{'id': 'toolu_01KNbjuc8utt6ZroFngmAcuj', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 438, 'output_tokens': 64, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\ntr = mk_toolres(r, ns=ns)\n\nFinding the sum of 604542 and 6458932\n\n\n\nsource\n\n\nClient.structured\n\n Client.structured (msgs:list, tools:Optional[list]=None,\n                    obj:Optional=None,\n                    ns:Optional[collections.abc.Mapping]=None, sp='',\n                    temp=0, maxtok=4096, prefill='', stream:bool=False,\n                    stop=None, tool_choice:Optional[dict]=None,\n                    metadata:MetadataParam|NotGiven=NOT_GIVEN,\n                    stop_sequences:List[str]|NotGiven=NOT_GIVEN, system:Un\n                    ion[str,Iterable[TextBlockParam]]|NotGiven=NOT_GIVEN,\n                    temperature:float|NotGiven=NOT_GIVEN,\n                    top_k:int|NotGiven=NOT_GIVEN,\n                    top_p:float|NotGiven=NOT_GIVEN,\n                    extra_headers:Headers|None=None,\n                    extra_query:Query|None=None,\n                    extra_body:Body|None=None,\n                    timeout:float|httpx.Timeout|None|NotGiven=NOT_GIVEN)\n\nReturn the value of all tool calls (generally used for structured outputs)\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmsgs\nlist\n\nList of messages in the dialog\n\n\ntools\nOptional\nNone\nList of tools to make available to Claude\n\n\nobj\nOptional\nNone\nClass to search for tools\n\n\nns\nOptional\nNone\nNamespace to search for tools\n\n\nsp\nstr\n\nThe system prompt\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nstream\nbool\nFalse\nStream response?\n\n\nstop\nNoneType\nNone\nStop sequence\n\n\ntool_choice\nOptional\nNone\nOptionally force use of some tool\n\n\nmetadata\nMetadataParam | NotGiven\nNOT_GIVEN\n\n\n\nstop_sequences\nList[str] | NotGiven\nNOT_GIVEN\n\n\n\nsystem\nUnion[str, Iterable[TextBlockParam]] | NotGiven\nNOT_GIVEN\n\n\n\ntemperature\nfloat | NotGiven\nNOT_GIVEN\n\n\n\ntop_k\nint | NotGiven\nNOT_GIVEN\n\n\n\ntop_p\nfloat | NotGiven\nNOT_GIVEN\n\n\n\nextra_headers\nHeaders | None\nNone\n\n\n\nextra_query\nQuery | None\nNone\n\n\n\nextra_body\nBody | None\nNone\n\n\n\ntimeout\nfloat | httpx.Timeout | None | NotGiven\nNOT_GIVEN\n\n\n\n\n\n\nExported source\n@patch\n@delegates(Client.__call__)\ndef structured(self:Client,\n               msgs:list, # List of messages in the dialog\n               tools:Optional[list]=None, # List of tools to make available to Claude\n               obj:Optional=None, # Class to search for tools\n               ns:Optional[abc.Mapping]=None, # Namespace to search for tools\n               **kwargs):\n    \"Return the value of all tool calls (generally used for structured outputs)\"\n    tools = listify(tools)\n    res = self(msgs, tools=tools, tool_choice=tools, **kwargs)\n    if ns is None: ns=mk_ns(*tools)\n    if obj is not None: ns = mk_ns(obj)\n    cts = getattr(res, 'content', [])\n    tcs = [call_func(o.name, o.input, ns=ns) for o in cts if isinstance(o,ToolUseBlock)]\n    return tcs\n\n\nAnthropic’s API does not support response formats directly, so instead we provide a structured method to use tool calling to achieve the same result. The result of the tool is not passed back to Claude in this case, but instead is returned directly to the user.\n\nc.structured(pr, tools=[sums])\n\nFinding the sum of 604542 and 6458932\n\n\n[7063474]",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#chat",
    "href": "core.html#chat",
    "title": "Claudette’s source",
    "section": "Chat",
    "text": "Chat\nRather than manually adding the responses to a dialog, we’ll create a simple Chat class to do that for us, each time we make a request. We’ll also store the system prompt and tools here, to avoid passing them every time.\n\nsource\n\nChat\n\n Chat (model:Optional[str]=None, cli:Optional[__main__.Client]=None,\n       sp='', tools:Optional[list]=None, temp=0,\n       cont_pr:Optional[str]=None)\n\nAnthropic chat client.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmodel\nOptional\nNone\nModel to use (leave empty if passing cli)\n\n\ncli\nOptional\nNone\nClient to use (leave empty if passing model)\n\n\nsp\nstr\n\nOptional system prompt\n\n\ntools\nOptional\nNone\nList of tools to make available to Claude\n\n\ntemp\nint\n0\nTemperature\n\n\ncont_pr\nOptional\nNone\nUser prompt to continue an assistant response: assistant,[user:“…”],assistant\n\n\n\n\n\nExported source\nclass Chat:\n    def __init__(self,\n                 model:Optional[str]=None, # Model to use (leave empty if passing `cli`)\n                 cli:Optional[Client]=None, # Client to use (leave empty if passing `model`)\n                 sp='', # Optional system prompt\n                 tools:Optional[list]=None, # List of tools to make available to Claude\n                 temp=0, # Temperature\n                 cont_pr:Optional[str]=None): # User prompt to continue an assistant response: assistant,[user:\"...\"],assistant\n        \"Anthropic chat client.\"\n        assert model or cli\n        assert cont_pr != \"\", \"cont_pr may not be an empty string\"\n        self.c = (cli or Client(model))\n        self.h,self.sp,self.tools,self.cont_pr,self.temp = [],sp,tools,cont_pr,temp\n\n    @property\n    def use(self): return self.c.use\n\n\nThe class stores the Client that will provide the responses in c, and a history of messages in h.\n\nsp = \"Never mention what tools you use.\"\nchat = Chat(model, sp=sp)\nchat.c.use, chat.h\n\n(In: 0; Out: 0; Cache create: 0; Cache read: 0; Total: 0, [])\n\n\nWe’ve shown the token usage but we really care about is pricing. Let’s extract the latest pricing from Anthropic into a pricing dict.\nWe’ll patch Usage to enable it compute the cost given pricing.\n\nsource\n\n\nUsage.cost\n\n Usage.cost (costs:tuple)\n\n\n\nExported source\n@patch\ndef cost(self:Usage, costs:tuple) -&gt; float:\n    cache_w, cache_r = getattr(self, \"cache_creation_input_tokens\",0), getattr(self, \"cache_read_input_tokens\",0)\n    return sum([self.input_tokens * costs[0] +  self.output_tokens * costs[1] +  cache_w * costs[2] + cache_r * costs[3]]) / 1e6\n\n\n\nchat.c.use.cost(pricing[model_types[chat.c.model]])\n\n0.0\n\n\nThis is clunky. Let’s add cost as a property for the Chat class. It will pass in the appropriate prices for the current model to the usage cost calculator.\n\nsource\n\n\nChat.cost\n\n Chat.cost ()\n\n\n\nExported source\n@patch(as_prop=True)\ndef cost(self: Chat) -&gt; float: return self.c.use.cost(pricing[model_types[self.c.model]])\n\n\n\nchat.cost\n\n0.0\n\n\n\nsource\n\n\nChat.__call__\n\n Chat.__call__ (pr=None, temp=None, maxtok=4096, stream=False, prefill='',\n                tool_choice:Optional[dict]=None, **kw)\n\nCall self as a function.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npr\nNoneType\nNone\nPrompt / message\n\n\ntemp\nNoneType\nNone\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nstream\nbool\nFalse\nStream response?\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\ntool_choice\nOptional\nNone\nOptionally force use of some tool\n\n\nkw\n\n\n\n\n\n\n\n\nExported source\n@patch\ndef _stream(self:Chat, res):\n    yield from res\n    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)\n\n\n\n\nExported source\n@patch\ndef _post_pr(self:Chat, pr, prev_role):\n    if pr is None and prev_role == 'assistant':\n        if self.cont_pr is None:\n            raise ValueError(\"Prompt must be given after assistant completion, or use `self.cont_pr`.\")\n        pr = self.cont_pr # No user prompt, keep the chain\n    if pr: self.h.append(mk_msg(pr))\n\n\n\n\nExported source\n@patch\ndef _append_pr(self:Chat,\n               pr=None,  # Prompt / message\n              ):\n    prev_role = nested_idx(self.h, -1, 'role') if self.h else 'assistant' # First message should be 'user'\n    if pr and prev_role == 'user': self() # already user request pending\n    self._post_pr(pr, prev_role)\n\n\n\n\nExported source\n@patch\ndef __call__(self:Chat,\n             pr=None,  # Prompt / message\n             temp=None, # Temperature\n             maxtok=4096, # Maximum tokens\n             stream=False, # Stream response?\n             prefill='', # Optional prefill to pass to Claude as start of its response\n             tool_choice:Optional[dict]=None, # Optionally force use of some tool\n             **kw):\n    if temp is None: temp=self.temp\n    self._append_pr(pr)\n    res = self.c(self.h, stream=stream, prefill=prefill, sp=self.sp, temp=temp, maxtok=maxtok,\n                 tools=self.tools, tool_choice=tool_choice,**kw)\n    if stream: return self._stream(res)\n    self.h += mk_toolres(self.c.result, ns=self.tools)\n    return res\n\n\nThe __call__ method just passes the request along to the Client, but rather than just passing in this one prompt, it appends it to the history and passes it all along. As a result, we now have state!\n\nchat = Chat(model, sp=sp)\n\n\nchat(\"I'm Jeremy\")\nchat(\"What's my name?\")\n\nYour name is Jeremy.\n\n\nid: msg_01GpNv4P5x9Gzc5mxxw9FgEL\ncontent: [{'text': 'Your name is Jeremy.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 41, 'output_tokens': 9, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nchat.use, chat.cost\n\n(In: 58; Out: 27; Cache create: 0; Cache read: 0; Total: 85, 0.000579)\n\n\nLet’s try out prefill too:\n\nq = \"Concisely, what is the meaning of life?\"\npref = 'According to Douglas Adams,'\n\n\nchat(q, prefill=pref)\n\nAccording to Douglas Adams,42. But seriously: To find purpose, create meaning, love, grow, and make a positive impact while experiencing life’s journey.\n\n\nid: msg_011s2iLranbHFhdsVg8sz6eY\ncontent: [{'text': \"According to Douglas Adams,42. But seriously: To find purpose, create meaning, love, grow, and make a positive impact while experiencing life's journey.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 69, 'output_tokens': 32, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nBy default messages must be in user, assistant, user format. If this isn’t followed (aka calling chat() without a user message) it will error out:\n\ntry: chat()\nexcept ValueError as e: print(\"Error:\", e)\n\nError: Prompt must be given after assistant completion, or use `self.cont_pr`.\n\n\nSetting cont_pr allows a “default prompt” to be specified when a prompt isn’t specified. Usually used to prompt the model to continue.\n\nchat.cont_pr = \"keep going...\"\nchat()\n\nTo build meaningful relationships, pursue passions, learn continuously, help others, appreciate beauty, overcome challenges, leave a positive legacy, and find personal fulfillment through whatever brings you joy and contributes to the greater good.\n\n\nid: msg_01Rz8oydLAinmSMyaKbmmpE9\ncontent: [{'text': 'To build meaningful relationships, pursue passions, learn continuously, help others, appreciate beauty, overcome challenges, leave a positive legacy, and find personal fulfillment through whatever brings you joy and contributes to the greater good.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 105, 'output_tokens': 54, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nWe can also use streaming:\n\nchat = Chat(model, sp=sp)\nfor o in chat(\"I'm Jeremy\", stream=True): print(o, end='')\n\nHello Jeremy! Nice to meet you. How are you today?\n\n\n\nfor o in chat(q, prefill=pref, stream=True): print(o, end='')\n\nAccording to Douglas Adams,  42. More seriously: to find purpose, love, grow, and make a positive impact while experiencing life's journey.\n\n\n\n\nChat tool use\nWe automagically get streamlined tool use as well:\n\npr = f\"What is {a}+{b}?\"\npr\n\n'What is 604542+6458932?'\n\n\n\nchat = Chat(model, sp=sp, tools=[sums])\nr = chat(pr)\nr\n\nFinding the sum of 604542 and 6458932\n\n\nLet me calculate that sum for you.\n\n\nid: msg_01MY2VWnZuU8jKyRKJ5FGzmM\ncontent: [{'text': 'Let me calculate that sum for you.', 'type': 'text'}, {'id': 'toolu_01JXnJ1ReFqx5ppX3y7UcQCB', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 437, 'output_tokens': 87, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nNow we need to send this result to Claude—calling the object with no parameters tells it to return the tool result to Claude:\n\nchat()\n\n604542 + 6458932 = 7063474\n\n\nid: msg_01Sog8j3pgYb3TBWPYwR4uQU\ncontent: [{'text': '604542 + 6458932 = 7063474', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 532, 'output_tokens': 22, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nIt should be correct, because it actually used our Python function to do the addition. Let’s check:\n\na+b\n\n7063474",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#images",
    "href": "core.html#images",
    "title": "Claudette’s source",
    "section": "Images",
    "text": "Images\nClaude can handle image data as well. As everyone knows, when testing image APIs you have to use a cute puppy.\n\n# Image is Cute_dog.jpg from Wikimedia\nfn = Path('samples/puppy.jpg')\ndisplay.Image(filename=fn, width=200)\n\n\n\n\n\n\n\n\n\nimg = fn.read_bytes()\n\n\n\nExported source\ndef _add_cache(d, cache):\n    \"Optionally add cache control\"\n    if cache: d[\"cache_control\"] = {\"type\": \"ephemeral\"}\n    return d\n\n\nClaude supports context caching by adding a cache_control header, so we provide an option to enable that.\n\nsource\n\nimg_msg\n\n img_msg (data:bytes, cache=False)\n\nConvert image data into an encoded dict\n\n\nExported source\ndef img_msg(data:bytes, cache=False)-&gt;dict:\n    \"Convert image `data` into an encoded `dict`\"\n    img = base64.b64encode(data).decode(\"utf-8\")\n    mtype = mimetypes.types_map['.'+imghdr.what(None, h=data)]\n    r = dict(type=\"base64\", media_type=mtype, data=img)\n    return _add_cache({\"type\": \"image\", \"source\": r}, cache)\n\n\nAnthropic have documented the particular dict structure that expect image data to be in, so we have a little function to create that for us.\n\nsource\n\n\ntext_msg\n\n text_msg (s:str, cache=False)\n\nConvert s to a text message\n\n\nExported source\ndef text_msg(s:str, cache=False)-&gt;dict:\n    \"Convert `s` to a text message\"\n    return _add_cache({\"type\": \"text\", \"text\": s}, cache)\n\n\nA Claude message can be a list of image and text parts. So we’ve also created a helper for making the text parts.\n\nq = \"In brief, what color flowers are in this image?\"\nmsg = mk_msg([img_msg(img), text_msg(q)])\n\n\nc([msg])\n\nIn this adorable puppy photo, there are purple/lavender colored flowers (appears to be asters or similar daisy-like flowers) in the background.\n\n\nid: msg_01Ej9XSFQKFtD9pUns5g7tom\ncontent: [{'text': 'In this adorable puppy photo, there are purple/lavender colored flowers (appears to be asters or similar daisy-like flowers) in the background.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 110, 'output_tokens': 44, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\n\nExported source\ndef _mk_content(src, cache=False):\n    \"Create appropriate content data structure based on type of content\"\n    if isinstance(src,str): return text_msg(src, cache=cache)\n    if isinstance(src,bytes): return img_msg(src, cache=cache)\n    if isinstance(src, abc.Mapping): return {k:_str_if_needed(v) for k,v in src.items()}\n    return _str_if_needed(src)\n\n\nThere’s not need to manually choose the type of message, since we figure that out from the data of the source data.\n\n_mk_content('Hi')\n\n{'type': 'text', 'text': 'Hi'}\n\n\n\nsource\n\n\nmk_msg\n\n mk_msg (content, role='user', cache=False, **kw)\n\nHelper to create a dict appropriate for a Claude message. kw are added as key/value pairs to the message\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncontent\n\n\nA string, list, or dict containing the contents of the message\n\n\nrole\nstr\nuser\nMust be ‘user’ or ‘assistant’\n\n\ncache\nbool\nFalse\n\n\n\nkw\n\n\n\n\n\n\n\n\nExported source\ndef mk_msg(content, # A string, list, or dict containing the contents of the message\n           role='user', # Must be 'user' or 'assistant'\n           cache=False,\n           **kw):\n    \"Helper to create a `dict` appropriate for a Claude message. `kw` are added as key/value pairs to the message\"\n    if hasattr(content, 'content'): content,role = content.content,content.role\n    if isinstance(content, abc.Mapping): content=content.get('content', content)\n    if not isinstance(content, list): content=[content]\n    content = [_mk_content(o, cache if islast else False) for islast,o in loop_last(content)] if content else '.'\n    return dict2obj(dict(role=role, content=content, **kw), list_func=list)\n\n\n\nmk_msg(['hi', 'there'], cache=True)\n\n{ 'content': [ {'text': 'hi', 'type': 'text'},\n               { 'cache_control': {'type': 'ephemeral'},\n                 'text': 'there',\n                 'type': 'text'}],\n  'role': 'user'}\n\n\n\nm = mk_msg(['hi', 'there'], cache=True)\n\nWhen we construct a message, we now use _mk_content to create the appropriate parts. Since a dialog contains multiple messages, and a message can contain multiple content parts, to pass a single message with multiple parts we have to use a list containing a single list:\n\nc([[img, q]])\n\nIn this adorable puppy photo, there are purple/lavender colored flowers (appears to be asters or similar daisy-like flowers) in the background.\n\n\nid: msg_014GQfAQF5FYU8a4Y8bvVm16\ncontent: [{'text': 'In this adorable puppy photo, there are purple/lavender colored flowers (appears to be asters or similar daisy-like flowers) in the background.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 110, 'output_tokens': 38, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAs promised (much!) earlier, we’ve now finally completed our definition of mk_msg, and this version is the one we export to the Python module.\n\n\nSome models unfortunately do not support image inputs such as Haiku 3.5\n\nmodel = models[-1]; model\n\n'claude-3-5-haiku-20241022'\n\n\n\nc = Client(model)\nc([[img, q]])\n\n\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nCell In[115], line 2\n      1 c = Client(model)\n----&gt; 2 c([[img, q]])\n\nCell In[72], line 19, in __call__(self, msgs, sp, temp, maxtok, prefill, stream, stop, tools, tool_choice, **kwargs)\n     17 if tool_choice: kwargs['tool_choice'] = mk_tool_choice(tool_choice)\n     18 msgs = self._precall(msgs, prefill, stop, kwargs)\n---&gt; 19 if any(t == 'image' for t in get_types(msgs)): assert not self.text_only, f\"Images are not supported by the current model type: {self.model}\"\n     20 if stream: return self._stream(msgs, prefill=prefill, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n     21 res = self.c.messages.create(model=self.model, messages=msgs, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n\nAssertionError: Images are not supported by the current model type: claude-3-5-haiku-20241022",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#third-party-providers",
    "href": "core.html#third-party-providers",
    "title": "Claudette’s source",
    "section": "Third party providers",
    "text": "Third party providers\n\nAmazon Bedrock\nThese are Amazon’s current Claude models:\n\nmodels_aws\n\n['anthropic.claude-3-opus-20240229-v1:0',\n 'anthropic.claude-3-5-sonnet-20241022-v2:0',\n 'anthropic.claude-3-sonnet-20240229-v1:0',\n 'anthropic.claude-3-haiku-20240307-v1:0']\n\n\n\n\n\n\n\n\nNote\n\n\n\nanthropic at version 0.34.2 seems not to install boto3 as a dependency. You may need to do a pip install boto3 or the creation of the Client below fails.\n\n\nProvided boto3 is installed, we otherwise don’t need any extra code to support Amazon Bedrock – we just have to set up the approach client:\n\nab = AnthropicBedrock(\n    aws_access_key=os.environ['AWS_ACCESS_KEY'],\n    aws_secret_key=os.environ['AWS_SECRET_KEY'],\n)\nclient = Client(models_aws[-1], ab)\n\n\nchat = Chat(cli=client)\n\n\nchat(\"I'm Jeremy\")\n\nIt’s nice to meet you, Jeremy! I’m Claude, an AI assistant created by Anthropic. How can I help you today?\n\n\nid: msg_bdrk_01JPBwsACbf1HZoNDUzbHNpJ\ncontent: [{'text': \"It's nice to meet you, Jeremy! I'm Claude, an AI assistant created by Anthropic. How can I help you today?\", 'type': 'text'}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 32}\n\n\n\n\n\n\nGoogle Vertex\n\nmodels_goog\n\n['claude-3-opus@20240229',\n 'claude-3-5-sonnet-v2@20241022',\n 'claude-3-sonnet@20240229',\n 'claude-3-haiku@20240307']\n\n\n\nfrom anthropic import AnthropicVertex\nimport google.auth\n\n\nproject_id = google.auth.default()[1]\nregion = \"us-east5\"\ngv = AnthropicVertex(project_id=project_id, region=region)\nclient = Client(models_goog[-1], gv)\n\n\nchat = Chat(cli=client)\n\n\nchat(\"I'm Jeremy\")",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "async.html#async-sdk",
    "href": "async.html#async-sdk",
    "title": "The async version",
    "section": "Async SDK",
    "text": "Async SDK\n\nmodel = models[1]\ncli = AsyncAnthropic()\n\n\nm = {'role': 'user', 'content': \"I'm Jeremy\"}\nr = await cli.messages.create(messages=[m], model=model, max_tokens=100)\nr\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_019gsEQs5dqb3kgwNJbTH27M\ncontent: [{'text': \"Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to talk about or any questions you have?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 36}\n\n\n\n\n\nsource\n\nAsyncClient\n\n AsyncClient (model, cli=None, log=False)\n\nAsync Anthropic messages client.\n\n\nExported source\nclass AsyncClient(Client):\n    def __init__(self, model, cli=None, log=False):\n        \"Async Anthropic messages client.\"\n        super().__init__(model,cli,log)\n        if not cli: self.c = AsyncAnthropic(default_headers={'anthropic-beta': 'prompt-caching-2024-07-31'})\n\n\n\nc = AsyncClient(model)\n\n\nc._r(r)\nc.use\n\nIn: 10; Out: 36; Total: 46\n\n\n\nsource\n\n\nAsyncClient.__call__\n\n AsyncClient.__call__ (msgs:list, sp='', temp=0, maxtok=4096, prefill='',\n                       stream:bool=False, stop=None, cli=None, log=False)\n\nMake an async call to Claude.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmsgs\nlist\n\nList of messages in the dialog\n\n\nsp\nstr\n\nThe system prompt\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nstream\nbool\nFalse\nStream response?\n\n\nstop\nNoneType\nNone\nStop sequence\n\n\ncli\nNoneType\nNone\n\n\n\nlog\nbool\nFalse\n\n\n\n\n\n\nExported source\n@patch\nasync def _stream(self:AsyncClient, msgs:list, prefill='', **kwargs):\n    async with self.c.messages.stream(model=self.model, messages=mk_msgs(msgs), **kwargs) as s:\n        if prefill: yield prefill\n        async for o in s.text_stream: yield o\n        self._log(await s.get_final_message(), prefill, msgs, kwargs)\n\n\n\n\nExported source\n@patch\n@delegates(Client)\nasync def __call__(self:AsyncClient,\n             msgs:list, # List of messages in the dialog\n             sp='', # The system prompt\n             temp=0, # Temperature\n             maxtok=4096, # Maximum tokens\n             prefill='', # Optional prefill to pass to Claude as start of its response\n             stream:bool=False, # Stream response?\n             stop=None, # Stop sequence\n             **kwargs):\n    \"Make an async call to Claude.\"\n    msgs = self._precall(msgs, prefill, stop, kwargs)\n    if stream: return self._stream(msgs, prefill=prefill, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    res = await self.c.messages.create(\n        model=self.model, messages=msgs, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    return self._log(res, prefill, msgs, maxtok, sp, temp, stream=stream, stop=stop, **kwargs)\n\n\n\nc = AsyncClient(model, log=True)\nc.use\n\nIn: 0; Out: 0; Total: 0\n\n\n\nc.model = models[1]\nawait c('Hi')\n\nHello! How can I assist you today? Feel free to ask any questions or let me know if you need help with anything.\n\n\nid: msg_01L9vqP9r1LcmvSk8vWGLbPo\ncontent: [{'text': 'Hello! How can I assist you today? Feel free to ask any questions or let me know if you need help with anything.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 8, 'output_tokens': 29, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nc.use\n\nIn: 8; Out: 29; Total: 37\n\n\n\nq = \"Concisely, what is the meaning of life?\"\npref = 'According to Douglas Adams,'\nawait c(q, prefill=pref)\n\nAccording to Douglas Adams, the meaning of life is 42. More seriously, there’s no universally agreed upon meaning of life. Many philosophers and religions have proposed different answers, but it remains an open question that individuals must grapple with for themselves.\n\n\nid: msg_01KAJbCneA2oCRPVm9EkyDXF\ncontent: [{'text': \"According to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon meaning of life. Many philosophers and religions have proposed different answers, but it remains an open question that individuals must grapple with for themselves.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 24, 'output_tokens': 51, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nasync for o in (await c('Hi', stream=True)): print(o, end='')\n\nHello! How can I assist you today? Feel free to ask any questions or let me know if you need help with anything.\n\n\n\nc.use\n\nIn: 40; Out: 109; Total: 149\n\n\n\nasync for o in (await c(q, prefill=pref, stream=True)): print(o, end='')\n\nAccording to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon meaning of life. Many philosophers and religions have proposed different answers, but it remains an open question that individuals must grapple with for themselves.\n\n\n\nc.use\n\nIn: 64; Out: 160; Total: 224\n\n\n\ndef sums(\n    a:int,  # First thing to sum\n    b:int=1 # Second thing to sum\n) -&gt; int: # The sum of the inputs\n    \"Adds a + b.\"\n    print(f\"Finding the sum of {a} and {b}\")\n    return a + b\n\n\na,b = 604542,6458932\npr = f\"What is {a}+{b}?\"\nsp = \"You are a summing expert.\"\n\n\ntools=[get_schema(sums)]\nchoice = mk_tool_choice('sums')\n\n\ntools = [get_schema(sums)]\nmsgs = mk_msgs(pr)\nr = await c(msgs, sp=sp, tools=tools, tool_choice=choice)\ntr = mk_toolres(r, ns=globals())\nmsgs += tr\ncontents(await c(msgs, sp=sp, tools=tools))\n\nFinding the sum of 604542 and 6458932\n\n\n'As a summing expert, I\\'m happy to help you with this addition. The sum of 604542 and 6458932 is 7063474.\\n\\nTo break it down:\\n604542 (first number)\\n+ 6458932 (second number)\\n= 7063474 (total sum)\\n\\nThis result was calculated using the \"sums\" function, which adds two numbers together. Is there anything else you\\'d like me to sum for you?'",
    "crumbs": [
      "The async version"
    ]
  },
  {
    "objectID": "async.html#asyncchat",
    "href": "async.html#asyncchat",
    "title": "The async version",
    "section": "AsyncChat",
    "text": "AsyncChat\n\nsource\n\nAsyncChat\n\n AsyncChat (model:Optional[str]=None,\n            cli:Optional[claudette.core.Client]=None, sp='',\n            tools:Optional[list]=None, temp=0, cont_pr:Optional[str]=None)\n\nAnthropic async chat client.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmodel\nOptional\nNone\nModel to use (leave empty if passing cli)\n\n\ncli\nOptional\nNone\nClient to use (leave empty if passing model)\n\n\nsp\nstr\n\n\n\n\ntools\nOptional\nNone\n\n\n\ntemp\nint\n0\n\n\n\ncont_pr\nOptional\nNone\n\n\n\n\n\n\nExported source\n@delegates()\nclass AsyncChat(Chat):\n    def __init__(self,\n                 model:Optional[str]=None, # Model to use (leave empty if passing `cli`)\n                 cli:Optional[Client]=None, # Client to use (leave empty if passing `model`)\n                 **kwargs):\n        \"Anthropic async chat client.\"\n        super().__init__(model, cli, **kwargs)\n        if not cli: self.c = AsyncClient(model)\n\n\n\nsp = \"Never mention what tools you use.\"\nchat = AsyncChat(model, sp=sp)\nchat.c.use, chat.h\n\n(In: 0; Out: 0; Total: 0, [])\n\n\n\nsource\n\n\nAsyncChat.__call__\n\n AsyncChat.__call__ (pr=None, temp=0, maxtok=4096, stream=False,\n                     prefill='', **kw)\n\nCall self as a function.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npr\nNoneType\nNone\nPrompt / message\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nstream\nbool\nFalse\nStream response?\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nkw\n\n\n\n\n\n\n\n\nExported source\n@patch\nasync def _stream(self:AsyncChat, res):\n    async for o in res: yield o\n    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)\n\n\n\n\nExported source\n@patch\nasync def _append_pr(self:AsyncChat, pr=None):\n    prev_role = nested_idx(self.h, -1, 'role') if self.h else 'assistant' # First message should be 'user' if no history\n    if pr and prev_role == 'user': await self()\n    self._post_pr(pr, prev_role)\n\n\n\n\nExported source\n@patch\nasync def __call__(self:AsyncChat,\n        pr=None,  # Prompt / message\n        temp=0, # Temperature\n        maxtok=4096, # Maximum tokens\n        stream=False, # Stream response?\n        prefill='', # Optional prefill to pass to Claude as start of its response\n        **kw):\n    await self._append_pr(pr)\n    if self.tools: kw['tools'] = [get_schema(o) for o in self.tools]\n    res = await self.c(self.h, stream=stream, prefill=prefill, sp=self.sp, temp=temp, maxtok=maxtok, **kw)\n    if stream: return self._stream(res)\n    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)\n    return res\n\n\n\nawait chat(\"I'm Jeremy\")\nawait chat(\"What's my name?\")\n\nYour name is Jeremy, as you mentioned in your previous message.\n\n\nid: msg_01NMugMXWpDP9iuTXeLkHarn\ncontent: [{'text': 'Your name is Jeremy, as you mentioned in your previous message.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 64, 'output_tokens': 16, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nq = \"Concisely, what is the meaning of life?\"\npref = 'According to Douglas Adams,'\nawait chat(q, prefill=pref)\n\nAccording to Douglas Adams, the meaning of life is 42. More seriously, there’s no universally agreed upon answer. Common philosophical perspectives include:\n\nFinding personal fulfillment\nServing others\nPursuing happiness\nCreating meaning through our choices\nExperiencing and appreciating existence\n\nUltimately, many believe each individual must determine their own life’s meaning.\n\n\nid: msg_01VPWUQn5Do1Kst8RYUDQvCu\ncontent: [{'text': \"According to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common philosophical perspectives include:\\n\\n1. Finding personal fulfillment\\n2. Serving others\\n3. Pursuing happiness\\n4. Creating meaning through our choices\\n5. Experiencing and appreciating existence\\n\\nUltimately, many believe each individual must determine their own life's meaning.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 100, 'output_tokens': 82, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nchat = AsyncChat(model, sp=sp)\nasync for o in (await chat(\"I'm Jeremy\", stream=True)): print(o, end='')\n\nHello Jeremy! It's nice to meet you. How are you doing today? Is there anything in particular you'd like to chat about or any questions I can help you with?\n\n\n\npr = f\"What is {a}+{b}?\"\nchat = AsyncChat(model, sp=sp, tools=[sums])\nr = await chat(pr)\nr\n\nFinding the sum of 604542 and 6458932\n\n\nTo answer this question, I can use the “sums” function to add these two numbers together. Let me do that for you.\n\n\nid: msg_015z1rffSWFxvj7rSpzc43ZE\ncontent: [{'text': 'To answer this question, I can use the \"sums\" function to add these two numbers together. Let me do that for you.', 'type': 'text'}, {'id': 'toolu_01SNKhtfnDQBC4RGY4mUCq1v', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 428, 'output_tokens': 101, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nawait chat()\n\nThe sum of 604542 and 6458932 is 7063474.\n\n\nid: msg_018KAsE2YGiXWjUJkLPrXpb2\ncontent: [{'text': 'The sum of 604542 and 6458932 is 7063474.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 543, 'output_tokens': 23, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nfn = Path('samples/puppy.jpg')\nimg = fn.read_bytes()\n\n\nq = \"In brief, what color flowers are in this image?\"\nmsg = mk_msg([img_msg(img), text_msg(q)])\nawait c([msg])\n\nThe flowers in this image are purple. They appear to be small, daisy-like flowers, possibly asters or some type of purple daisy, blooming in the background behind the adorable puppy in the foreground.\n\n\nid: msg_017qgZggLjUY915mWbWCkb9X\ncontent: [{'text': 'The flowers in this image are purple. They appear to be small, daisy-like flowers, possibly asters or some type of purple daisy, blooming in the background behind the adorable puppy in the foreground.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 110, 'output_tokens': 50, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}",
    "crumbs": [
      "The async version"
    ]
  },
  {
    "objectID": "CHANGELOG.html",
    "href": "CHANGELOG.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "CHANGELOG.html#section",
    "href": "CHANGELOG.html#section",
    "title": "",
    "section": "0.1.0",
    "text": "0.1.0\n\nBreaking Changes\n\ntool_choice is no longer a Chat instance variable; instead it is a parameter to Chat.__call__\n\n\n\nNew Features\n\nAdd temp param to Chat (#38)\n\n\n\nBugs Squashed\n\npr included but not used (#37)\nfix tool use bug (#35), thanks to @comhar"
  },
  {
    "objectID": "CHANGELOG.html#section-1",
    "href": "CHANGELOG.html#section-1",
    "title": "",
    "section": "0.0.10",
    "text": "0.0.10\n\nNew Features\n\nAdd Client.structured (#32)\nUse dict2obj (#30)\nStore tool call result without stringifying (#29)"
  },
  {
    "objectID": "CHANGELOG.html#section-2",
    "href": "CHANGELOG.html#section-2",
    "title": "",
    "section": "0.0.9",
    "text": "0.0.9\n\nNew Features\n\nAsync support (#21)"
  },
  {
    "objectID": "CHANGELOG.html#section-3",
    "href": "CHANGELOG.html#section-3",
    "title": "",
    "section": "0.0.7",
    "text": "0.0.7\n\nNew Features\n\nPrompt caching (#20)\nadd markdown to doc output (#19)\nSupport vscode details tags (#18)\nAdd a cont_pr param to Chat as a “default” prompt #15), thanks to @tom-pollak\n\n\n\nBugs Squashed\n\nExplicit tool_choice causes chat() to call tool twice. (#11)"
  },
  {
    "objectID": "CHANGELOG.html#section-4",
    "href": "CHANGELOG.html#section-4",
    "title": "",
    "section": "0.0.6",
    "text": "0.0.6\n\nNew Features\n\nDefault chat prompt & function calling refactor (#15), thanks to @tom-pollak"
  },
  {
    "objectID": "CHANGELOG.html#section-5",
    "href": "CHANGELOG.html#section-5",
    "title": "",
    "section": "0.0.5",
    "text": "0.0.5\n\nNew Features\n\nBetter support for stop sequences (#12), thanks to @xl0"
  },
  {
    "objectID": "CHANGELOG.html#section-6",
    "href": "CHANGELOG.html#section-6",
    "title": "",
    "section": "0.0.3",
    "text": "0.0.3\n\nNew Features\n\nAmazon Bedrock and Google Vertex support (#7)\n\n\n\nBug Fixes\n\nUpdate model paths for non-beta tool use (#2), thanks to @sarahpannn"
  },
  {
    "objectID": "CHANGELOG.html#section-7",
    "href": "CHANGELOG.html#section-7",
    "title": "",
    "section": "0.0.1",
    "text": "0.0.1\n\nInitial release"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "claudette",
    "section": "",
    "text": "NB: If you are reading this in GitHub’s readme, we recommend you instead read the much more nicely formatted documentation format of this tutorial.\nClaudette is a wrapper for Anthropic’s Python SDK.\nThe SDK works well, but it is quite low level – it leaves the developer to do a lot of stuff manually. That’s a lot of extra work and boilerplate! Claudette automates pretty much everything that can be automated, whilst providing full control. Amongst the features provided:\nYou’ll need to set the ANTHROPIC_API_KEY environment variable to the key provided to you by Anthropic in order to use this library.\nNote that this library is the first ever “literate nbdev” project. That means that the actual source code for the library is a rendered Jupyter Notebook which includes callout notes and tips, HTML tables and images, detailed explanations, and teaches how and why the code is written the way it is. Even if you’ve never used the Anthropic Python SDK or Claude API before, you should be able to read the source code. Click Claudette’s Source to read it, or clone the git repo and execute the notebook yourself to see every step of the creation process in action. The tutorial below includes links to API details which will take you to relevant parts of the source. The reason this project is a new kind of literal program is because we take seriously Knuth’s call to action, that we have a “moral commitment” to never write an “illiterate program” – and so we have a commitment to making literate programming and easy and pleasant experience. (For more on this, see this talk from Hamel Husain.)",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "claudette",
    "section": "Install",
    "text": "Install\npip install claudette",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "claudette",
    "section": "Getting started",
    "text": "Getting started\nAnthropic’s Python SDK will automatically be installed with Claudette, if you don’t already have it.\n\nimport os\n# os.environ['ANTHROPIC_LOG'] = 'debug'\n\nTo print every HTTP request and response in full, uncomment the above line.\n\nfrom claudette import *\n\nClaudette only exports the symbols that are needed to use the library, so you can use import * to import them. Alternatively, just use:\nimport claudette\n…and then add the prefix claudette. to any usages of the module.\nClaudette provides models, which is a list of models currently available from the SDK.\n\nmodels\n\n['claude-3-opus-20240229',\n 'claude-3-5-sonnet-20241022',\n 'claude-3-haiku-20240307']\n\n\nFor these examples, we’ll use Sonnet 3.5, since it’s awesome!\n\nmodel = models[1]",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#chat",
    "href": "index.html#chat",
    "title": "claudette",
    "section": "Chat",
    "text": "Chat\nThe main interface to Claudette is the Chat class, which provides a stateful interface to Claude:\n\nchat = Chat(model, sp=\"\"\"You are a helpful and concise assistant.\"\"\")\nchat(\"I'm Jeremy\")\n\nHello Jeremy, nice to meet you.\n\n\nid: msg_015oK9jEcra3TEKHUGYULjWB\ncontent: [{'text': 'Hello Jeremy, nice to meet you.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 19, 'output_tokens': 11, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nr = chat(\"What's my name?\")\nr\n\nYour name is Jeremy.\n\n\nid: msg_01Si8sTFJe8d8vq7enanbAwj\ncontent: [{'text': 'Your name is Jeremy.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 38, 'output_tokens': 8, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nr = chat(\"What's my name?\")\nr\n\nYour name is Jeremy.\n\n\nid: msg_01BHWRoAX8eBsoLn2bzpBkvx\ncontent: [{'text': 'Your name is Jeremy.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 54, 'output_tokens': 8, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nAs you see above, displaying the results of a call in a notebook shows just the message contents, with the other details hidden behind a collapsible section. Alternatively you can print the details:\n\nprint(r)\n\nMessage(id='msg_01BHWRoAX8eBsoLn2bzpBkvx', content=[TextBlock(text='Your name is Jeremy.', type='text')], model='claude-3-5-sonnet-20241022', role='assistant', stop_reason='end_turn', stop_sequence=None, type='message', usage=In: 54; Out: 8; Cache create: 0; Cache read: 0; Total: 62)\n\n\nClaude supports adding an extra assistant message at the end, which contains the prefill – i.e. the text we want Claude to assume the response starts with. Let’s try it out:\n\nchat(\"Concisely, what is the meaning of life?\",\n     prefill='According to Douglas Adams,')\n\nAccording to Douglas Adams,42. Philosophically, it’s to find personal meaning through relationships, purpose, and experiences.\n\n\nid: msg_01R9RvMdFwea9iRX5uYSSHG7\ncontent: [{'text': \"According to Douglas Adams,42. Philosophically, it's to find personal meaning through relationships, purpose, and experiences.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 82, 'output_tokens': 23, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nYou can add stream=True to stream the results as soon as they arrive (although you will only see the gradual generation if you execute the notebook yourself, of course!)\n\nfor o in chat(\"Concisely, what book was that in?\", prefill='It was in', stream=True):\n    print(o, end='')\n\nIt was in \"The Hitchhiker's Guide to the Galaxy\" by Douglas Adams.\n\n\n\nAsync\nAlternatively, you can use AsyncChat (or AsyncClient) for the async versions, e.g:\n\nchat = AsyncChat(model)\nawait chat(\"I'm Jeremy\")\n\nHi Jeremy! Nice to meet you. I’m Claude, an AI assistant created by Anthropic. How can I help you today?\n\n\nid: msg_016Q8cdc3sPWBS8eXcNj841L\ncontent: [{'text': \"Hi Jeremy! Nice to meet you. I'm Claude, an AI assistant created by Anthropic. How can I help you today?\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 31, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nRemember to use async for when streaming in this case:\n\nasync for o in await chat(\"Concisely, what is the meaning of life?\",\n                          prefill='According to Douglas Adams,', stream=True):\n    print(o, end='')\n\nAccording to Douglas Adams,  it's 42. But in my view, there's no single universal meaning - each person must find their own purpose through relationships, personal growth, contribution to others, and pursuit of what they find meaningful.",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#prompt-caching",
    "href": "index.html#prompt-caching",
    "title": "claudette",
    "section": "Prompt caching",
    "text": "Prompt caching\nIf you use mk_msg(msg, cache=True), then the message is cached using Claude’s prompt caching feature. For instance, here we use caching when asking about Claudette’s readme file:\n\nchat = Chat(model, sp=\"\"\"You are a helpful and concise assistant.\"\"\")\n\n\nnbtxt = Path('README.txt').read_text()\nmsg = f'''&lt;README&gt;\n{nbtxt}\n&lt;/README&gt;\nIn brief, what is the purpose of this project based on the readme?'''\nr = chat(mk_msg(msg, cache=True))\nr\n\nClaudette is a high-level wrapper for Anthropic’s Python SDK that automates common tasks and provides additional functionality. Its main features include:\n\nA Chat class for stateful dialogs\nSupport for prefill (controlling Claude’s initial response words)\nConvenient image handling\nSimple tool use API integration\nSupport for multiple model providers (Anthropic, AWS Bedrock, Google Vertex)\n\nThe project is notable for being the first “literate nbdev” project, meaning its source code is written as a detailed, readable Jupyter Notebook that includes explanations, examples, and teaching material alongside the functional code.\nThe goal is to simplify working with Claude’s API while maintaining full control, reducing boilerplate code and manual work that would otherwise be needed with the base SDK.\n\n\nid: msg_014rVQnYoZXZuyWUCMELG1QW\ncontent: [{'text': 'Claudette is a high-level wrapper for Anthropic\\'s Python SDK that automates common tasks and provides additional functionality. Its main features include:\\n\\n1. A Chat class for stateful dialogs\\n2. Support for prefill (controlling Claude\\'s initial response words)\\n3. Convenient image handling\\n4. Simple tool use API integration\\n5. Support for multiple model providers (Anthropic, AWS Bedrock, Google Vertex)\\n\\nThe project is notable for being the first \"literate nbdev\" project, meaning its source code is written as a detailed, readable Jupyter Notebook that includes explanations, examples, and teaching material alongside the functional code.\\n\\nThe goal is to simplify working with Claude\\'s API while maintaining full control, reducing boilerplate code and manual work that would otherwise be needed with the base SDK.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 4, 'output_tokens': 179, 'cache_creation_input_tokens': 7205, 'cache_read_input_tokens': 0}\n\n\n\n\nThe response records the a cache has been created using these input tokens:\n\nprint(r.usage)\n\nUsage(input_tokens=4, output_tokens=179, cache_creation_input_tokens=7205, cache_read_input_tokens=0)\n\n\nWe can now ask a followup question in this chat:\n\nr = chat('How does it make tool use more ergonomic?')\nr\n\nAccording to the README, Claudette makes tool use more ergonomic in several ways:\n\nIt uses docments to make Python function definitions more user-friendly - each parameter and return value should have a type and description\nIt handles the tool calling process automatically - when Claude returns a tool_use message, Claudette manages calling the tool with the provided parameters behind the scenes\nIt provides a toolloop method that can handle multiple tool calls in a single step to solve more complex problems\nIt allows you to pass a list of tools to the Chat constructor and optionally force Claude to always use a specific tool via tool_choice\n\nHere’s a simple example from the README:\ndef sums(\n    a:int,  # First thing to sum \n    b:int=1 # Second thing to sum\n) -&gt; int: # The sum of the inputs\n    \"Adds a + b.\"\n    print(f\"Finding the sum of {a} and {b}\")\n    return a + b\n\nchat = Chat(model, sp=sp, tools=[sums], tool_choice='sums')\nThis makes it much simpler compared to manually handling all the tool use logic that would be required with the base SDK.\n\n\nid: msg_01EdUvvFBnpPxMtdLRCaSZAU\ncontent: [{'text': 'According to the README, Claudette makes tool use more ergonomic in several ways:\\n\\n1. It uses docments to make Python function definitions more user-friendly - each parameter and return value should have a type and description\\n\\n2. It handles the tool calling process automatically - when Claude returns a tool_use message, Claudette manages calling the tool with the provided parameters behind the scenes\\n\\n3. It provides atoolloopmethod that can handle multiple tool calls in a single step to solve more complex problems\\n\\n4. It allows you to pass a list of tools to the Chat constructor and optionally force Claude to always use a specific tool viatool_choice\\n\\nHere\\'s a simple example from the README:\\n\\n```python\\ndef sums(\\n    a:int,  # First thing to sum \\n    b:int=1 # Second thing to sum\\n) -&gt; int: # The sum of the inputs\\n    \"Adds a + b.\"\\n    print(f\"Finding the sum of {a} and {b}\")\\n    return a + b\\n\\nchat = Chat(model, sp=sp, tools=[sums], tool_choice=\\'sums\\')\\n```\\n\\nThis makes it much simpler compared to manually handling all the tool use logic that would be required with the base SDK.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 197, 'output_tokens': 280, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 7205}\n\n\n\n\nWe can see that this only used ~200 regular input tokens – the 7000+ context tokens have been read from cache.\n\nprint(r.usage)\n\nUsage(input_tokens=197, output_tokens=280, cache_creation_input_tokens=0, cache_read_input_tokens=7205)\n\n\n\nchat.use\n\nIn: 201; Out: 459; Cache create: 7205; Cache read: 7205; Total: 15070",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#tool-use",
    "href": "index.html#tool-use",
    "title": "claudette",
    "section": "Tool use",
    "text": "Tool use\nTool use lets Claude use external tools.\nWe use docments to make defining Python functions as ergonomic as possible. Each parameter (and the return value) should have a type, and a docments comment with the description of what it is. As an example we’ll write a simple function that adds numbers together, and will tell us when it’s being called:\n\ndef sums(\n    a:int,  # First thing to sum\n    b:int=1 # Second thing to sum\n) -&gt; int: # The sum of the inputs\n    \"Adds a + b.\"\n    print(f\"Finding the sum of {a} and {b}\")\n    return a + b\n\nSometimes Claude will say something like “according to the sums tool the answer is” – generally we’d rather it just tells the user the answer, so we can use a system prompt to help with this:\n\nsp = \"Never mention what tools you use.\"\n\nWe’ll get Claude to add up some long numbers:\n\na,b = 604542,6458932\npr = f\"What is {a}+{b}?\"\npr\n\n'What is 604542+6458932?'\n\n\nTo use tools, pass a list of them to Chat:\n\nchat = Chat(model, sp=sp, tools=[sums])\n\nTo force Claude to always answer using a tool, set tool_choice to that function name. When Claude needs to use a tool, it doesn’t return the answer, but instead returns a tool_use message, which means we have to call the named tool with the provided parameters.\n\nr = chat(pr, tool_choice='sums')\nr\n\nFinding the sum of 604542 and 6458932\n\n\nToolUseBlock(id=‘toolu_014ip2xWyEq8RnAccVT4SySt’, input={‘a’: 604542, ‘b’: 6458932}, name=‘sums’, type=‘tool_use’)\n\n\nid: msg_014xrPyotyiBmFSctkp1LZHk\ncontent: [{'id': 'toolu_014ip2xWyEq8RnAccVT4SySt', 'input': {'a': 604542, 'b': 6458932}, 'name': 'sums', 'type': 'tool_use'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 442, 'output_tokens': 53, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nClaudette handles all that for us – we just call it again, and it all happens automatically:\n\nchat()\n\nThe sum of 604542 and 6458932 is 7063474.\n\n\nid: msg_01151puJxG8Fa6k6QSmzwKQA\ncontent: [{'text': 'The sum of 604542 and 6458932 is 7063474.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 524, 'output_tokens': 23, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nYou can see how many tokens have been used at any time by checking the use property. Note that (as of May 2024) tool use in Claude uses a lot of tokens, since it automatically adds a large system prompt.\n\nchat.use\n\nIn: 966; Out: 76; Cache create: 0; Cache read: 0; Total: 1042\n\n\nWe can do everything needed to use tools in a single step, by using Chat.toolloop. This can even call multiple tools as needed solve a problem. For example, let’s define a tool to handle multiplication:\n\ndef mults(\n    a:int,  # First thing to multiply\n    b:int=1 # Second thing to multiply\n) -&gt; int: # The product of the inputs\n    \"Multiplies a * b.\"\n    print(f\"Finding the product of {a} and {b}\")\n    return a * b\n\nNow with a single call we can calculate (a+b)*2 – by passing show_trace we can see each response from Claude in the process:\n\nchat = Chat(model, sp=sp, tools=[sums,mults])\npr = f'Calculate ({a}+{b})*2'\npr\n\n'Calculate (604542+6458932)*2'\n\n\n\nchat.toolloop(pr, trace_func=print)\n\nFinding the sum of 604542 and 6458932\n[{'role': 'user', 'content': [{'type': 'text', 'text': 'Calculate (604542+6458932)*2'}]}, {'role': 'assistant', 'content': [TextBlock(text=\"I'll help you break this down into steps:\\n\\nFirst, let's add those numbers:\", type='text'), ToolUseBlock(id='toolu_01St5UKxYUU4DKC96p2PjgcD', input={'a': 604542, 'b': 6458932}, name='sums', type='tool_use')]}, {'role': 'user', 'content': [{'type': 'tool_result', 'tool_use_id': 'toolu_01St5UKxYUU4DKC96p2PjgcD', 'content': '7063474'}]}]\nFinding the product of 7063474 and 2\n[{'role': 'assistant', 'content': [TextBlock(text=\"Now, let's multiply this result by 2:\", type='text'), ToolUseBlock(id='toolu_01FpmRG4ZskKEWN1gFZzx49s', input={'a': 7063474, 'b': 2}, name='mults', type='tool_use')]}, {'role': 'user', 'content': [{'type': 'tool_result', 'tool_use_id': 'toolu_01FpmRG4ZskKEWN1gFZzx49s', 'content': '14126948'}]}]\n[{'role': 'assistant', 'content': [TextBlock(text='The final result is 14,126,948.', type='text')]}]\n\n\nThe final result is 14,126,948.\n\n\nid: msg_0162teyBcJHriUzZXMPz4r5d\ncontent: [{'text': 'The final result is 14,126,948.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 741, 'output_tokens': 15, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#structured-data",
    "href": "index.html#structured-data",
    "title": "claudette",
    "section": "Structured data",
    "text": "Structured data\nIf you just want the immediate result from a single tool, use Client.structured.\n\ncli = Client(model)\n\n\ndef sums(\n    a:int,  # First thing to sum\n    b:int=1 # Second thing to sum\n) -&gt; int: # The sum of the inputs\n    \"Adds a + b.\"\n    print(f\"Finding the sum of {a} and {b}\")\n    return a + b\n\n\ncli.structured(\"What is 604542+6458932\", sums)\n\nFinding the sum of 604542 and 6458932\n\n\n[7063474]\n\n\nThis is particularly useful for getting back structured information, e.g:\n\nclass President:\n    \"Information about a president of the United States\"\n    def __init__(self, \n                first:str, # first name\n                last:str, # last name\n                spouse:str, # name of spouse\n                years_in_office:str, # format: \"{start_year}-{end_year}\"\n                birthplace:str, # name of city\n                birth_year:int # year of birth, `0` if unknown\n        ):\n        assert re.match(r'\\d{4}-\\d{4}', years_in_office), \"Invalid format: `years_in_office`\"\n        store_attr()\n\n    __repr__ = basic_repr('first, last, spouse, years_in_office, birthplace, birth_year')\n\n\ncli.structured(\"Provide key information about the 3rd President of the United States\", President)\n\n[President(first='Thomas', last='Jefferson', spouse='Martha Wayles', years_in_office='1801-1809', birthplace='Shadwell', birth_year=1743)]",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#images",
    "href": "index.html#images",
    "title": "claudette",
    "section": "Images",
    "text": "Images\nClaude can handle image data as well. As everyone knows, when testing image APIs you have to use a cute puppy.\n\nfn = Path('samples/puppy.jpg')\ndisplay.Image(filename=fn, width=200)\n\n\n\n\n\n\n\n\nWe create a Chat object as before:\n\nchat = Chat(model)\n\nClaudette expects images as a list of bytes, so we read in the file:\n\nimg = fn.read_bytes()\n\nPrompts to Claudette can be lists, containing text, images, or both, eg:\n\nchat([img, \"In brief, what color flowers are in this image?\"])\n\nIn this adorable puppy photo, there are purple/lavender colored flowers (appears to be asters or similar daisy-like flowers) in the background.\n\n\nid: msg_01LHjGv1WwFvDsWUbyLmTEKT\ncontent: [{'text': 'In this adorable puppy photo, there are purple/lavender colored flowers (appears to be asters or similar daisy-like flowers) in the background.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 110, 'output_tokens': 37, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nThe image is included as input tokens.\n\nchat.use\n\nIn: 110; Out: 37; Cache create: 0; Cache read: 0; Total: 147\n\n\nAlternatively, Claudette supports creating a multi-stage chat with separate image and text prompts. For instance, you can pass just the image as the initial prompt (in which case Claude will make some general comments about what it sees), and then follow up with questions in additional prompts:\n\nchat = Chat(model)\nchat(img)\n\nWhat an adorable Cavalier King Charles Spaniel puppy! The photo captures the classic brown and white coloring of the breed, with those soulful dark eyes that are so characteristic. The puppy is lying in the grass, and there are lovely purple asters blooming in the background, creating a beautiful natural setting. The combination of the puppy’s sweet expression and the delicate flowers makes for a charming composition. Cavalier King Charles Spaniels are known for their gentle, affectionate nature, and this little one certainly seems to embody those traits with its endearing look.\n\n\nid: msg_01Ciyymq44uwp2iYwRZdKWNN\ncontent: [{'text': \"What an adorable Cavalier King Charles Spaniel puppy! The photo captures the classic brown and white coloring of the breed, with those soulful dark eyes that are so characteristic. The puppy is lying in the grass, and there are lovely purple asters blooming in the background, creating a beautiful natural setting. The combination of the puppy's sweet expression and the delicate flowers makes for a charming composition. Cavalier King Charles Spaniels are known for their gentle, affectionate nature, and this little one certainly seems to embody those traits with its endearing look.\", 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 98, 'output_tokens': 130, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nchat('What direction is the puppy facing?')\n\nThe puppy is facing towards the left side of the image. Its head is positioned so we can see its right side profile, though it appears to be looking slightly towards the camera, giving us a good view of its distinctive brown and white facial markings and one of its dark eyes. The puppy is lying down with its white chest/front visible against the green grass.\n\n\nid: msg_01AeR9eWjbxa788YF97iErtN\ncontent: [{'text': 'The puppy is facing towards the left side of the image. Its head is positioned so we can see its right side profile, though it appears to be looking slightly towards the camera, giving us a good view of its distinctive brown and white facial markings and one of its dark eyes. The puppy is lying down with its white chest/front visible against the green grass.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 239, 'output_tokens': 79, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\n\nchat('What color is it?')\n\nThe puppy has a classic Cavalier King Charles Spaniel coat with a rich chestnut brown (sometimes called Blenheim) coloring on its ears and patches on its face, combined with a bright white base color. The white is particularly prominent on its face (creating a distinctive blaze down the center) and chest area. This brown and white combination is one of the most recognizable color patterns for the breed.\n\n\nid: msg_01R91AqXG7pLc8hK24F5mc7x\ncontent: [{'text': 'The puppy has a classic Cavalier King Charles Spaniel coat with a rich chestnut brown (sometimes called Blenheim) coloring on its ears and patches on its face, combined with a bright white base color. The white is particularly prominent on its face (creating a distinctive blaze down the center) and chest area. This brown and white combination is one of the most recognizable color patterns for the breed.', 'type': 'text'}]\nmodel: claude-3-5-sonnet-20241022\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 326, 'output_tokens': 92, 'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0}\n\n\n\n\nNote that the image is passed in again for every input in the dialog, so that number of input tokens increases quickly with this kind of chat. (For large images, using prompt caching might be a good idea.)\n\nchat.use\n\nIn: 663; Out: 301; Cache create: 0; Cache read: 0; Total: 964",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#other-model-providers",
    "href": "index.html#other-model-providers",
    "title": "claudette",
    "section": "Other model providers",
    "text": "Other model providers\nYou can also use 3rd party providers of Anthropic models, as shown here.\n\nAmazon Bedrock\nThese are the models available through Bedrock:\n\nmodels_aws\n\n['anthropic.claude-3-opus-20240229-v1:0',\n 'anthropic.claude-3-5-sonnet-20241022-v2:0',\n 'anthropic.claude-3-sonnet-20240229-v1:0',\n 'anthropic.claude-3-haiku-20240307-v1:0']\n\n\nTo use them, call AnthropicBedrock with your access details, and pass that to Client:\n\nfrom anthropic import AnthropicBedrock\n\n\nab = AnthropicBedrock(\n    aws_access_key=os.environ['AWS_ACCESS_KEY'],\n    aws_secret_key=os.environ['AWS_SECRET_KEY'],\n)\nclient = Client(models_aws[-1], ab)\n\nNow create your Chat object passing this client to the cli parameter – and from then on, everything is identical to the previous examples.\n\nchat = Chat(cli=client)\nchat(\"I'm Jeremy\")\n\nIt’s nice to meet you, Jeremy! I’m Claude, an AI assistant created by Anthropic. How can I help you today?\n\n\nid: msg_bdrk_01V3B5RF2Pyzmh3NeR8xMMpq\ncontent: [{'text': \"It's nice to meet you, Jeremy! I'm Claude, an AI assistant created by Anthropic. How can I help you today?\", 'type': 'text'}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {'input_tokens': 10, 'output_tokens': 32}\n\n\n\n\n\n\nGoogle Vertex\nThese are the models available through Vertex:\n\nmodels_goog\n\n['claude-3-opus@20240229',\n 'claude-3-5-sonnet-v2@20241022',\n 'claude-3-sonnet@20240229',\n 'claude-3-haiku@20240307']\n\n\nTo use them, call AnthropicVertex with your access details, and pass that to Client:\n\nfrom anthropic import AnthropicVertex\nimport google.auth\n\n\nproject_id = google.auth.default()[1]\ngv = AnthropicVertex(project_id=project_id, region=\"us-east5\")\nclient = Client(models_goog[-1], gv)\n\n\nchat = Chat(cli=client)\nchat(\"I'm Jeremy\")",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#extensions",
    "href": "index.html#extensions",
    "title": "claudette",
    "section": "Extensions",
    "text": "Extensions\n\nPydantic Structured Ouput",
    "crumbs": [
      "claudette"
    ]
  }
]